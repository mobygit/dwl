diff --git a/.gitignore b/.gitignore
index 5c28541..0dde90e 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,3 +3,4 @@ dwl
 *-protocol.c
 *-protocol.h
 .ccls-cache
+config.h
diff --git a/Makefile b/Makefile
index c7df8c5..fc2ed86 100644
--- a/Makefile
+++ b/Makefile
@@ -9,6 +9,7 @@ DWLDEVCFLAGS = -pedantic -Wall -Wextra -Wdeclaration-after-statement -Wno-unused
 	-Werror=strict-prototypes -Werror=implicit -Werror=return-type -Werror=incompatible-pointer-types
 
 # CFLAGS / LDFLAGS
+<<<<<<< HEAD
 PKGS      = wlroots wayland-server xkbcommon libinput pixman-1 $(XLIBS)
 DWLCFLAGS = `$(PKG_CONFIG) --cflags $(PKGS)` $(DWLCPPFLAGS) $(DWLDEVCFLAGS) $(CFLAGS)
 LDLIBS    = `$(PKG_CONFIG) --libs $(PKGS)` -lm $(LIBS)
@@ -22,6 +23,17 @@ dwl-ipc-unstable-v2-protocol.o: dwl-ipc-unstable-v2-protocol.h
 PREFIX?= /usr/local
 BINDIR?= $(PREFIX)/bin
 DESKTOP?= /usr/share/wayland-sessions
+=======
+PKGS      = wlroots wayland-server xkbcommon libinput $(XLIBS)
+DWLCFLAGS = `$(PKG_CONFIG) --cflags $(PKGS)` $(DWLCPPFLAGS) $(DWLDEVCFLAGS) $(CFLAGS)
+LDLIBS    = `$(PKG_CONFIG) --libs $(PKGS)` $(LIBS)
+
+all: dwl
+dwl: dwl.o util.o net-tapesoftware-dwl-wm-unstable-v1-protocol.o
+	$(CC) dwl.o util.o net-tapesoftware-dwl-wm-unstable-v1-protocol.o $(LDLIBS) $(LDFLAGS) $(DWLCFLAGS) -o $@
+dwl.o: dwl.c config.mk config.h client.h xdg-shell-protocol.h wlr-layer-shell-unstable-v1-protocol.h net-tapesoftware-dwl-wm-unstable-v1-protocol.o
+util.o: util.c util.h
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 
 # wayland-scanner is a tool which generates C headers and rigging for Wayland
 # protocols, which are specified in XML. wlroots requires you to rig these up
@@ -35,6 +47,7 @@ xdg-shell-protocol.h:
 wlr-layer-shell-unstable-v1-protocol.h:
 	$(WAYLAND_SCANNER) server-header \
 		protocols/wlr-layer-shell-unstable-v1.xml $@
+<<<<<<< HEAD
 dwl-ipc-unstable-v2-protocol.h:
 	$(WAYLAND_SCANNER) server-header \
 		protocols/dwl-ipc-unstable-v2.xml $@
@@ -44,16 +57,34 @@ dwl-ipc-unstable-v2-protocol.c:
 pointer-constraints-unstable-v1-protocol.h:
 	$(WAYLAND_SCANNER) server-header \
 		$(WAYLAND_PROTOCOLS)/unstable/pointer-constraints/pointer-constraints-unstable-v1.xml $@
+=======
+
+net-tapesoftware-dwl-wm-unstable-v1-protocol.h: protocols/net-tapesoftware-dwl-wm-unstable-v1.xml
+	$(WAYLAND_SCANNER) server-header \
+		protocols/net-tapesoftware-dwl-wm-unstable-v1.xml $@
+net-tapesoftware-dwl-wm-unstable-v1-protocol.c: protocols/net-tapesoftware-dwl-wm-unstable-v1.xml
+	$(WAYLAND_SCANNER) private-code \
+		protocols/net-tapesoftware-dwl-wm-unstable-v1.xml $@
+net-tapesoftware-dwl-wm-unstable-v1-protocol.o: net-tapesoftware-dwl-wm-unstable-v1-protocol.h
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 
 config.h:
 	cp config.def.h $@
 clean:
+<<<<<<< HEAD
 	rm -f dwl *.o *-protocol.h xdg-shell-protocol.c
+=======
+	rm -f dwl *.o *-protocol.h
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 
 dist: clean
 	mkdir -p dwl-$(VERSION)
 	cp -R LICENSE* Makefile README.md client.h config.def.h\
+<<<<<<< HEAD
 		config.mk protocols dwl.1 dwl.c util.c util.h\
+=======
+		config.mk protocols dwl.1 dwl.c util.c util.h dwl.desktop\
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 		dwl-$(VERSION)
 	tar -caf dwl-$(VERSION).tar.gz dwl-$(VERSION)
 	rm -rf dwl-$(VERSION)
@@ -65,10 +96,18 @@ install: dwl
 	mkdir -p $(DESTDIR)$(MANDIR)/man1
 	cp -f dwl.1 $(DESTDIR)$(MANDIR)/man1
 	chmod 644 $(DESTDIR)$(MANDIR)/man1/dwl.1
+<<<<<<< HEAD
 	install -Dm 644 dwl.desktop $(DESKTOP)/dwl.desktop
 uninstall:
 	rm -f $(DESTDIR)$(PREFIX)/bin/dwl $(DESTDIR)$(MANDIR)/man1/dwl.1
 	rm -f $(DESKTOP)/dwl.desktop
+=======
+	mkdir -p $(DESTDIR)$(DATADIR)/wayland-sessions
+	cp -f dwl.desktop $(DESTDIR)$(DATADIR)/wayland-sessions/dwl.desktop
+	chmod 644 $(DESTDIR)$(DATADIR)/wayland-sessions/dwl.desktop
+uninstall:
+	rm -f $(DESTDIR)$(PREFIX)/bin/dwl $(DESTDIR)$(MANDIR)/man1/dwl.1 $(DESTDIR)$(DATADIR)/wayland-sessions/dwl.desktop
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 
 .SUFFIXES: .c .o
 .c.o:
diff --git a/client.h b/client.h
index 5a45edc..fbbeff5 100644
--- a/client.h
+++ b/client.h
@@ -324,6 +324,17 @@ client_send_close(Client *c)
 }
 
 static inline void
+<<<<<<< HEAD
+=======
+client_set_border_color(Client *c, const float color[static 4])
+{
+	int i;
+	for (i = 0; i < 4; i++)
+		wlr_scene_rect_set_color(c->border[i], color);
+}
+
+static inline void
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 client_set_fullscreen(Client *c, int fullscreen)
 {
 #ifdef XWAYLAND
diff --git a/config.def.h b/config.def.h
index 5127907..109b479 100644
--- a/config.def.h
+++ b/config.def.h
@@ -1,3 +1,4 @@
+<<<<<<< HEAD
 /* appearance */
 static const int sloppyfocus               = 1;  /* focus follows mouse */
 static const int bypass_surface_visibility = 0;  /* 1 means idle inhibitors will disable idle tracking even if it's surface isn't visible  */
@@ -30,17 +31,51 @@ static const Rule rules[] = {
 	/* app_id     title       tags mask     isfloating   monitor */
 	/* examples: */
 	{ "Gimp",     NULL,       0,            1,           -1 },
+=======
+/* Taken from https://github.com/djpohly/dwl/issues/466 */
+#define COLOR(hex)    { ((hex >> 24) & 0xFF) / 255.0f, \
+                        ((hex >> 16) & 0xFF) / 255.0f, \
+                        ((hex >> 8) & 0xFF) / 255.0f, \
+                        (hex & 0xFF) / 255.0f }
+/* appearance */
+static const int sloppyfocus               = 1;  /* focus follows mouse */
+static const int bypass_surface_visibility = 0;  /* 1 means idle inhibitors will disable idle tracking even if it's surface isn't visible  */
+static const unsigned int borderpx         = 1;  /* border pixel of windows */
+static const float bordercolor[]           = COLOR(0x444444ff);
+static const float focuscolor[]            = COLOR(0x005577ff);
+static const float urgentcolor[]           = COLOR(0xff0000ff);
+/* To conform the xdg-protocol, set the alpha to zero to restore the old behavior */
+static const float fullscreen_bg[]         = {0.1, 0.1, 0.1, 1.0}; /* You can also use glsl colors */
+
+/* tagging - TAGCOUNT must be no greater than 31 */
+#define TAGCOUNT (9)
+
+/* logging */
+static int log_level = WLR_ERROR;
+
+static const Rule rules[] = {
+	/* app_id     title       tags mask     isfloating   monitor */
+	/* examples:
+	{ "Gimp",     NULL,       0,            1,           -1 },
+	*/
+	{ "firefox",  NULL,       1 << 8,       0,           -1 },
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 };
 
 /* layout(s) */
 static const Layout layouts[] = {
 	/* symbol     arrange function */
 	{ "[]=",      tile },
+<<<<<<< HEAD
 	//{ "><>",      NULL },    /* no layout function means floating behavior */
 	{ "[M]",      monocle },
 	{ "TTT",      bstack },
 	{ "===",      bstackhoriz },
 	{ "[D]",      deck },
+=======
+	{ "><>",      NULL },    /* no layout function means floating behavior */
+	{ "[M]",      monocle },
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 };
 
 /* monitors */
@@ -111,16 +146,24 @@ static const enum libinput_config_tap_button_map button_map = LIBINPUT_CONFIG_TA
 #define MODKEY WLR_MODIFIER_ALT
 
 #define TAGKEYS(KEY,SKEY,TAG) \
+<<<<<<< HEAD
 	{ MODKEY,                    -1, KEY,            view,            {.ui = 1 << TAG} }, \
 	{ MODKEY|WLR_MODIFIER_CTRL,  -1, KEY,            toggleview,      {.ui = 1 << TAG} }, \
 	{ MODKEY|WLR_MODIFIER_SHIFT, -1, SKEY,           tag,             {.ui = 1 << TAG} }, \
 	{ MODKEY|WLR_MODIFIER_CTRL|WLR_MODIFIER_SHIFT,-1,SKEY,toggletag,  {.ui = 1 << TAG} }
+=======
+	{ MODKEY,                    KEY,            view,            {.ui = 1 << TAG} }, \
+	{ MODKEY|WLR_MODIFIER_CTRL,  KEY,            toggleview,      {.ui = 1 << TAG} }, \
+	{ MODKEY|WLR_MODIFIER_SHIFT, SKEY,           tag,             {.ui = 1 << TAG} }, \
+	{ MODKEY|WLR_MODIFIER_CTRL|WLR_MODIFIER_SHIFT,SKEY,toggletag, {.ui = 1 << TAG} }
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 
 /* helper for spawning shell commands in the pre dwm-5.0 fashion */
 #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
 
 /* commands */
 static const char *termcmd[] = { "foot", NULL };
+<<<<<<< HEAD
 static const char *menucmd[] = { "/bin/sh", "-c", "ddmenu_path | wmenu -f "JetBrainsMono NF Thin 12" -N 100E23 -n 8A889D -M 585273 | s
 h", NULL };
 
@@ -169,6 +212,36 @@ static const Key keys[] = {
 	{ MODKEY,                    -1, XKB_KEY_period,     focusmon,       {.i = WLR_DIRECTION_RIGHT} },
 	{ MODKEY|WLR_MODIFIER_SHIFT, -1, XKB_KEY_less,       tagmon,         {.i = WLR_DIRECTION_LEFT} },
 	{ MODKEY|WLR_MODIFIER_SHIFT, -1, XKB_KEY_greater,    tagmon,         {.i = WLR_DIRECTION_RIGHT} },
+=======
+static const char *menucmd[] = { "bemenu-run", NULL };
+
+static const Key keys[] = {
+	/* Note that Shift changes certain key codes: c -> C, 2 -> at, etc. */
+	/* modifier                  key                 function        argument */
+	{ MODKEY,                    XKB_KEY_p,          spawn,          {.v = menucmd} },
+	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Return,     spawn,          {.v = termcmd} },
+	{ MODKEY,                    XKB_KEY_j,          focusstack,     {.i = +1} },
+	{ MODKEY,                    XKB_KEY_k,          focusstack,     {.i = -1} },
+	{ MODKEY,                    XKB_KEY_i,          incnmaster,     {.i = +1} },
+	{ MODKEY,                    XKB_KEY_d,          incnmaster,     {.i = -1} },
+	{ MODKEY,                    XKB_KEY_h,          setmfact,       {.f = -0.05} },
+	{ MODKEY,                    XKB_KEY_l,          setmfact,       {.f = +0.05} },
+	{ MODKEY,                    XKB_KEY_Return,     zoom,           {0} },
+	{ MODKEY,                    XKB_KEY_Tab,        view,           {0} },
+	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_C,          killclient,     {0} },
+	{ MODKEY,                    XKB_KEY_t,          setlayout,      {.v = &layouts[0]} },
+	{ MODKEY,                    XKB_KEY_f,          setlayout,      {.v = &layouts[1]} },
+	{ MODKEY,                    XKB_KEY_m,          setlayout,      {.v = &layouts[2]} },
+	{ MODKEY,                    XKB_KEY_space,      setlayout,      {0} },
+	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_space,      togglefloating, {0} },
+	{ MODKEY,                    XKB_KEY_e,         togglefullscreen, {0} },
+	{ MODKEY,                    XKB_KEY_0,          view,           {.ui = ~0} },
+	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_parenright, tag,            {.ui = ~0} },
+	{ MODKEY,                    XKB_KEY_comma,      focusmon,       {.i = WLR_DIRECTION_LEFT} },
+	{ MODKEY,                    XKB_KEY_period,     focusmon,       {.i = WLR_DIRECTION_RIGHT} },
+	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_less,       tagmon,         {.i = WLR_DIRECTION_LEFT} },
+	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_greater,    tagmon,         {.i = WLR_DIRECTION_RIGHT} },
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	TAGKEYS(          XKB_KEY_1, XKB_KEY_exclam,                     0),
 	TAGKEYS(          XKB_KEY_2, XKB_KEY_at,                         1),
 	TAGKEYS(          XKB_KEY_3, XKB_KEY_numbersign,                 2),
@@ -178,10 +251,18 @@ static const Key keys[] = {
 	TAGKEYS(          XKB_KEY_7, XKB_KEY_ampersand,                  6),
 	TAGKEYS(          XKB_KEY_8, XKB_KEY_asterisk,                   7),
 	TAGKEYS(          XKB_KEY_9, XKB_KEY_parenleft,                  8),
+<<<<<<< HEAD
 	{ MODKEY|WLR_MODIFIER_SHIFT, -1, XKB_KEY_Q,          quit,           {0} },
 
 	/* Ctrl-Alt-Backspace and Ctrl-Alt-Fx used to be handled by X server */
 #define CHVT(n) { WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,-1,XKB_KEY_XF86Switch_VT_##n, chvt, {.ui = (n)} }
+=======
+	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Q,          quit,           {0} },
+
+	/* Ctrl-Alt-Backspace and Ctrl-Alt-Fx used to be handled by X server */
+	{ WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,XKB_KEY_Terminate_Server, quit, {0} },
+#define CHVT(n) { WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,XKB_KEY_XF86Switch_VT_##n, chvt, {.ui = (n)} }
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	CHVT(1), CHVT(2), CHVT(3), CHVT(4), CHVT(5), CHVT(6),
 	CHVT(7), CHVT(8), CHVT(9), CHVT(10), CHVT(11), CHVT(12),
 };
diff --git a/config.mk b/config.mk
index 8f5584a..b6bbc15 100644
--- a/config.mk
+++ b/config.mk
@@ -6,9 +6,19 @@ PKG_CONFIG = pkg-config
 # paths
 PREFIX = /usr/local
 MANDIR = $(PREFIX)/share/man
+<<<<<<< HEAD
 
 #XWAYLAND =
 #XLIBS =
 # Uncomment to build XWayland support
 XWAYLAND = -DXWAYLAND
 XLIBS = xcb xcb-icccm
+=======
+DATADIR = $(PREFIX)/share
+
+XWAYLAND =
+XLIBS =
+# Uncomment to build XWayland support
+#XWAYLAND = -DXWAYLAND
+#XLIBS = xcb xcb-icccm
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
diff --git a/dwl.1 b/dwl.1
index cae1036..5dd2112 100644
--- a/dwl.1
+++ b/dwl.1
@@ -7,6 +7,10 @@
 .Sh SYNOPSIS
 .Nm
 .Op Fl v
+<<<<<<< HEAD
+=======
+.Op Fl d
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 .Op Fl s Ar startup command
 .Sh DESCRIPTION
 .Nm
@@ -22,6 +26,15 @@ option,
 writes its name and version to standard error and exits unsuccessfully.
 .Pp
 When given the
+<<<<<<< HEAD
+=======
+.Fl d
+option,
+.Nm
+enables full wlroots logging, including debug information.
+.Pp
+When given the
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 .Fl s
 option,
 .Nm
@@ -101,7 +114,11 @@ These environment variables are used by
 A directory where temporary user files, such as the Wayland socket,
 are stored.
 .It Ev XDG_CONFIG_DIR
+<<<<<<< HEAD
 A directory containung configuration of various programs and
+=======
+A directory containing configuration of various programs and
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 libraries, including libxkbcommon.
 .It Ev DISPLAY , WAYLAND_DISPLAY , WAYLAND_SOCKET
 Tell how to connect to an underlying X11 or Wayland server.
diff --git a/dwl.c b/dwl.c
index 0d7296c..dbc6372 100644
--- a/dwl.c
+++ b/dwl.c
@@ -1,16 +1,22 @@
 /*
  * See LICENSE file for copyright and license details.
  */
+<<<<<<< HEAD
 
 #ifndef POINTERCONSTRAINTS
 #define POINTERCONSTRAINTS
 #endif
 
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 #include <getopt.h>
 #include <libinput.h>
 #include <limits.h>
 #include <linux/input-event-codes.h>
+<<<<<<< HEAD
 #include <pixman-1/pixman.h>
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 #include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -39,11 +45,17 @@
 #include <wlr/types/wlr_output_layout.h>
 #include <wlr/types/wlr_output_management_v1.h>
 #include <wlr/types/wlr_pointer.h>
+<<<<<<< HEAD
 #include <wlr/types/wlr_pointer_constraints_v1.h>
 #include <wlr/types/wlr_presentation_time.h>
 #include <wlr/types/wlr_primary_selection.h>
 #include <wlr/types/wlr_primary_selection_v1.h>
 #include <wlr/types/wlr_relative_pointer_v1.h>
+=======
+#include <wlr/types/wlr_presentation_time.h>
+#include <wlr/types/wlr_primary_selection.h>
+#include <wlr/types/wlr_primary_selection_v1.h>
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 #include <wlr/types/wlr_scene.h>
 #include <wlr/types/wlr_screencopy_v1.h>
 #include <wlr/types/wlr_seat.h>
@@ -58,6 +70,7 @@
 #include <wlr/types/wlr_xdg_decoration_v1.h>
 #include <wlr/types/wlr_xdg_output_v1.h>
 #include <wlr/types/wlr_xdg_shell.h>
+<<<<<<< HEAD
 #include <wlr/util/box.h>
 #include <wlr/util/log.h>
 #include <wlr/util/region.h>
@@ -69,6 +82,17 @@
 #endif
 
 #include "dwl-ipc-unstable-v2-protocol.h"
+=======
+#include <wlr/util/log.h>
+#include <xkbcommon/xkbcommon.h>
+#include "net-tapesoftware-dwl-wm-unstable-v1-protocol.h"
+#ifdef XWAYLAND
+#include <wlr/xwayland.h>
+#include <xcb/xcb.h>
+#include <xcb/xcb_icccm.h>
+#endif
+
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 #include "util.h"
 
 /* macros */
@@ -78,7 +102,11 @@
 #define VISIBLEON(C, M)         ((M) && (C)->mon == (M) && ((C)->tags & (M)->tagset[(M)->seltags]))
 #define LENGTH(X)               (sizeof X / sizeof X[0])
 #define END(A)                  ((A) + LENGTH(A))
+<<<<<<< HEAD
 #define TAGMASK                 ((1u << tagcount) - 1)
+=======
+#define TAGMASK                 ((1u << TAGCOUNT) - 1)
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 #define LISTEN(E, L, H)         wl_signal_add((E), ((L)->notify = (H), (L)))
 #define IDLE_NOTIFY_ACTIVITY    wlr_idle_notify_activity(idle, seat), wlr_idle_notifier_v1_notify_activity(idle_notifier, seat)
 
@@ -105,7 +133,10 @@ typedef struct {
 	const Arg arg;
 } Button;
 
+<<<<<<< HEAD
 typedef struct Pertag Pertag;
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 typedef struct Monitor Monitor;
 typedef struct {
 	/* Must keep these three elements in this order */
@@ -141,6 +172,7 @@ typedef struct {
 } Client;
 
 typedef struct {
+<<<<<<< HEAD
     struct wl_list link;
     struct wl_resource *resource;
     Monitor *monitor;
@@ -149,6 +181,9 @@ typedef struct {
 typedef struct {
 	uint32_t mod;
 	xkb_keysym_t chain;
+=======
+	uint32_t mod;
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	xkb_keysym_t keysym;
 	void (*func)(const Arg *);
 	const Arg arg;
@@ -191,9 +226,20 @@ typedef struct {
 	void (*arrange)(Monitor *);
 } Layout;
 
+<<<<<<< HEAD
 struct Monitor {
 	struct wl_list link;
     struct wl_list dwl_ipc_outputs;
+=======
+typedef struct {
+	struct wl_list link;
+	struct wl_resource *resource;
+	struct Monitor *monitor;
+} DwlWmMonitor;
+
+struct Monitor {
+	struct wl_list link;
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	struct wlr_output *wlr_output;
 	struct wlr_scene_output *scene_output;
 	struct wlr_scene_rect *fullscreen_bg; /* See createmon() for info */
@@ -204,12 +250,17 @@ struct Monitor {
 	struct wlr_box m; /* monitor area, layout-relative */
 	struct wlr_box w; /* window area, layout-relative */
 	struct wl_list layers[4]; /* LayerSurface::link */
+<<<<<<< HEAD
 	const Layout *lt[2];
 	int gappih;           /* horizontal gap between windows */
 	int gappiv;           /* vertical gap between windows */
 	int gappoh;           /* horizontal outer gaps */
 	int gappov;           /* vertical outer gaps */
 	Pertag *pertag;
+=======
+	struct wl_list dwl_wm_monitor_link;
+	const Layout *lt[2];
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	unsigned int seltags;
 	unsigned int sellt;
 	uint32_t tagset[2];
@@ -229,6 +280,7 @@ typedef struct {
 } MonitorRule;
 
 typedef struct {
+<<<<<<< HEAD
 	struct wlr_pointer_constraint_v1 *constraint;
 	Client *focused;
 
@@ -237,6 +289,8 @@ typedef struct {
 } PointerConstraint;
 
 typedef struct {
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	const char *id;
 	const char *title;
 	uint32_t tags;
@@ -260,10 +314,15 @@ static void arrange(Monitor *m);
 static void arrangelayer(Monitor *m, struct wl_list *list,
 		struct wlr_box *usable_area, int exclusive);
 static void arrangelayers(Monitor *m);
+<<<<<<< HEAD
 static void autostartexec(void);
 static void axisnotify(struct wl_listener *listener, void *data);
 static void buttonpress(struct wl_listener *listener, void *data);
 static void checkconstraintregion(void);
+=======
+static void axisnotify(struct wl_listener *listener, void *data);
+static void buttonpress(struct wl_listener *listener, void *data);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 static void chvt(const Arg *arg);
 static void checkidleinhibitor(struct wlr_surface *exclude);
 static void cleanup(void);
@@ -273,7 +332,10 @@ static void closemon(Monitor *m);
 static void commitlayersurfacenotify(struct wl_listener *listener, void *data);
 static void commitnotify(struct wl_listener *listener, void *data);
 static void createdecoration(struct wl_listener *listener, void *data);
+<<<<<<< HEAD
 static void commitpointerconstraint(struct wl_listener *listener, void *data);
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 static void createidleinhibitor(struct wl_listener *listener, void *data);
 static void createkeyboard(struct wlr_keyboard *keyboard);
 static void createlayersurface(struct wl_listener *listener, void *data);
@@ -281,18 +343,23 @@ static void createlocksurface(struct wl_listener *listener, void *data);
 static void createmon(struct wl_listener *listener, void *data);
 static void createnotify(struct wl_listener *listener, void *data);
 static void createpointer(struct wlr_pointer *pointer);
+<<<<<<< HEAD
 static void createpointerconstraint(struct wl_listener *listener, void *data);
 static void cursorconstrain(struct wlr_pointer_constraint_v1 *constraint);
 static void cursorframe(struct wl_listener *listener, void *data);
 static void deck(Monitor *m);
 static void defaultgaps(const Arg *arg);
 static void cursorwarptoconstrainthint(void);
+=======
+static void cursorframe(struct wl_listener *listener, void *data);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 static void destroydragicon(struct wl_listener *listener, void *data);
 static void destroyidleinhibitor(struct wl_listener *listener, void *data);
 static void destroylayersurfacenotify(struct wl_listener *listener, void *data);
 static void destroylock(SessionLock *lock, int unlocked);
 static void destroylocksurface(struct wl_listener *listener, void *data);
 static void destroynotify(struct wl_listener *listener, void *data);
+<<<<<<< HEAD
 static void destroypointerconstraint(struct wl_listener *listener, void *data);
 static void destroysessionlock(struct wl_listener *listener, void *data);
 static void destroysessionmgr(struct wl_listener *listener, void *data);
@@ -308,6 +375,11 @@ static void dwl_ipc_output_set_client_tags(struct wl_client *client, struct wl_r
 static void dwl_ipc_output_set_layout(struct wl_client *client, struct wl_resource *resource, uint32_t index);
 static void dwl_ipc_output_set_tags(struct wl_client *client, struct wl_resource *resource, uint32_t tagmask, uint32_t toggle_tagset);
 static void dwl_ipc_output_release(struct wl_client *client, struct wl_resource *resource);
+=======
+static void destroysessionlock(struct wl_listener *listener, void *data);
+static void destroysessionmgr(struct wl_listener *listener, void *data);
+static Monitor *dirtomon(enum wlr_direction dir);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 static void focusclient(Client *c, int lift);
 static void focusmon(const Arg *arg);
 static void focusstack(const Arg *arg);
@@ -315,6 +387,7 @@ static Client *focustop(Monitor *m);
 static void fullscreennotify(struct wl_listener *listener, void *data);
 static void handlesig(int signo);
 static void incnmaster(const Arg *arg);
+<<<<<<< HEAD
 static void incgaps(const Arg *arg);
 static void incigaps(const Arg *arg);
 static void incihgaps(const Arg *arg);
@@ -322,6 +395,8 @@ static void incivgaps(const Arg *arg);
 static void incogaps(const Arg *arg);
 static void incohgaps(const Arg *arg);
 static void incovgaps(const Arg *arg);
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 static void inputdevice(struct wl_listener *listener, void *data);
 static int keybinding(uint32_t mods, xkb_keysym_t sym);
 static void keypress(struct wl_listener *listener, void *data);
@@ -334,14 +409,21 @@ static void mapnotify(struct wl_listener *listener, void *data);
 static void maximizenotify(struct wl_listener *listener, void *data);
 static void monocle(Monitor *m);
 static void motionabsolute(struct wl_listener *listener, void *data);
+<<<<<<< HEAD
 static void motionnotify(uint32_t time, struct wlr_input_device *device, double sx,
 		double sy, double sx_unaccel, double sy_unaccel);
+=======
+static void motionnotify(uint32_t time);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 static void motionrelative(struct wl_listener *listener, void *data);
 static void moveresize(const Arg *arg);
 static void outputmgrapply(struct wl_listener *listener, void *data);
 static void outputmgrapplyortest(struct wlr_output_configuration_v1 *config, int test);
 static void outputmgrtest(struct wl_listener *listener, void *data);
+<<<<<<< HEAD
 static void pointerconstraintsetregion(struct wl_listener *listener, void *data);
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 static void pointerfocus(Client *c, struct wlr_surface *surface,
 		double sx, double sy, uint32_t time);
 static void printstatus(void);
@@ -353,7 +435,10 @@ static void run(char *startup_cmd);
 static void setcursor(struct wl_listener *listener, void *data);
 static void setfloating(Client *c, int floating);
 static void setfullscreen(Client *c, int fullscreen);
+<<<<<<< HEAD
 static void setgaps(int oh, int ov, int ih, int iv);
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 static void setlayout(const Arg *arg);
 static void setmfact(const Arg *arg);
 static void setmon(Client *c, Monitor *m, uint32_t newtags);
@@ -367,10 +452,15 @@ static void tagmon(const Arg *arg);
 static void tile(Monitor *m);
 static void togglefloating(const Arg *arg);
 static void togglefullscreen(const Arg *arg);
+<<<<<<< HEAD
 static void togglegaps(const Arg *arg);
 static void toggletag(const Arg *arg);
 static void toggleview(const Arg *arg);
 static void toggle_visibility(const Arg *arg);
+=======
+static void toggletag(const Arg *arg);
+static void toggleview(const Arg *arg);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 static void unlocksession(struct wl_listener *listener, void *data);
 static void unmaplayersurfacenotify(struct wl_listener *listener, void *data);
 static void unmapnotify(struct wl_listener *listener, void *data);
@@ -383,8 +473,15 @@ static Monitor *xytomon(double x, double y);
 static void xytonode(double x, double y, struct wlr_surface **psurface,
 		Client **pc, LayerSurface **pl, double *nx, double *ny);
 static void zoom(const Arg *arg);
+<<<<<<< HEAD
 static void bstack(Monitor *m);
 static void bstackhoriz(Monitor *m);
+=======
+
+static void dwl_wm_bind(struct wl_client *client, void *data,
+		uint32_t version, uint32_t id);
+static void dwl_wm_printstatus(Monitor *monitor);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 
 /* variables */
 static const char broken[] = "broken";
@@ -392,7 +489,10 @@ static const char *cursor_image = "left_ptr";
 static pid_t child_pid = -1;
 static int locked;
 static void *exclusive_focus;
+<<<<<<< HEAD
 static xkb_keysym_t chainkey = -1;
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 static struct wl_display *dpy;
 static struct wlr_backend *backend;
 static struct wlr_scene *scene;
@@ -417,6 +517,7 @@ static struct wlr_layer_shell_v1 *layer_shell;
 static struct wlr_output_manager_v1 *output_mgr;
 static struct wlr_virtual_keyboard_manager_v1 *virtual_keyboard_mgr;
 
+<<<<<<< HEAD
 static struct wlr_relative_pointer_manager_v1 *relative_pointer_mgr;
 static struct wlr_pointer_constraints_v1 *pointer_constraints;
 static struct wl_listener pointer_constraint_commit;
@@ -424,6 +525,8 @@ static PointerConstraint *active_constraint;
 static pixman_region32_t active_confine;
 static int active_confine_requires_warp;
 
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 static struct wlr_cursor *cursor;
 static struct wlr_xcursor_manager *cursor_mgr;
 
@@ -442,8 +545,11 @@ static struct wlr_box sgeom;
 static struct wl_list mons;
 static Monitor *selmon;
 
+<<<<<<< HEAD
 static int enablegaps = 1;   /* enables gaps, used by togglegaps */
 
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 /* global event handlers */
 static struct wl_listener cursor_axis = {.notify = axisnotify};
 static struct wl_listener cursor_button = {.notify = buttonpress};
@@ -451,15 +557,21 @@ static struct wl_listener cursor_frame = {.notify = cursorframe};
 static struct wl_listener cursor_motion = {.notify = motionrelative};
 static struct wl_listener cursor_motion_absolute = {.notify = motionabsolute};
 static struct wl_listener drag_icon_destroy = {.notify = destroydragicon};
+<<<<<<< HEAD
 static struct zdwl_ipc_manager_v2_interface dwl_manager_implementation = {.release = dwl_ipc_manager_release, .get_output = dwl_ipc_manager_get_output};
 static struct zdwl_ipc_output_v2_interface dwl_output_implementation = {.release = dwl_ipc_output_release, .set_tags = dwl_ipc_output_set_tags, .set_layout = dwl_ipc_output_set_layout, .set_client_tags = dwl_ipc_output_set_client_tags};
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 static struct wl_listener idle_inhibitor_create = {.notify = createidleinhibitor};
 static struct wl_listener idle_inhibitor_destroy = {.notify = destroyidleinhibitor};
 static struct wl_listener layout_change = {.notify = updatemons};
 static struct wl_listener new_input = {.notify = inputdevice};
 static struct wl_listener new_virtual_keyboard = {.notify = virtualkeyboard};
 static struct wl_listener new_output = {.notify = createmon};
+<<<<<<< HEAD
 static struct wl_listener new_pointer_constraint = {.notify = createpointerconstraint};
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 static struct wl_listener new_xdg_surface = {.notify = createnotify};
 static struct wl_listener new_xdg_decoration = {.notify = createdecoration};
 static struct wl_listener new_layer_shell_surface = {.notify = createlayersurface};
@@ -478,13 +590,21 @@ static struct wl_listener session_lock_mgr_destroy = {.notify = destroysessionmg
 static void activatex11(struct wl_listener *listener, void *data);
 static void configurex11(struct wl_listener *listener, void *data);
 static void createnotifyx11(struct wl_listener *listener, void *data);
+<<<<<<< HEAD
 static Atom getatom(xcb_connection_t *xc, const char *name);
+=======
+static xcb_atom_t getatom(xcb_connection_t *xc, const char *name);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 static void sethints(struct wl_listener *listener, void *data);
 static void xwaylandready(struct wl_listener *listener, void *data);
 static struct wl_listener new_xwayland_surface = {.notify = createnotifyx11};
 static struct wl_listener xwayland_ready = {.notify = xwaylandready};
 static struct wlr_xwayland *xwayland;
+<<<<<<< HEAD
 static Atom netatom[NetLast];
+=======
+static xcb_atom_t netatom[NetLast];
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 #endif
 
 /* configuration, allows nested code to access above variables */
@@ -493,6 +613,7 @@ static Atom netatom[NetLast];
 /* attempt to encapsulate suck into one file */
 #include "client.h"
 
+<<<<<<< HEAD
 static pid_t *autostart_pids;
 static size_t autostart_len;
 struct Pertag {
@@ -503,6 +624,8 @@ struct Pertag {
 	const Layout *ltidxs[TAGCOUNT + 1][2]; /* matrix of tags and layouts indexes  */
 };
 
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 /* function implementations */
 void
 applybounds(Client *c, struct wlr_box *bbox)
@@ -576,7 +699,11 @@ arrange(Monitor *m)
 
 	if (m->lt[m->sellt]->arrange)
 		m->lt[m->sellt]->arrange(m);
+<<<<<<< HEAD
 	motionnotify(0, NULL, 0, 0, 0, 0);
+=======
+	motionnotify(0);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	checkidleinhibitor(NULL);
 }
 
@@ -644,6 +771,7 @@ arrangelayers(Monitor *m)
 }
 
 void
+<<<<<<< HEAD
 autostartexec(void) {
 	const char *const *p;
 	size_t i = 0;
@@ -665,6 +793,8 @@ autostartexec(void) {
 }
 
 void
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 axisnotify(struct wl_listener *listener, void *data)
 {
 	/* This event is forwarded by the cursor when a pointer emits an axis event,
@@ -719,7 +849,11 @@ buttonpress(struct wl_listener *listener, void *data)
 			 * we will send an enter event after which the client will provide us
 			 * a cursor surface */
 			wlr_seat_pointer_clear_focus(seat);
+<<<<<<< HEAD
 			motionnotify(0, NULL, 0, 0, 0, 0);
+=======
+			motionnotify(0);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 			/* Drop the window off on its new monitor */
 			selmon = xytomon(cursor->x, cursor->y);
 			setmon(grabc, selmon, 0);
@@ -736,6 +870,7 @@ buttonpress(struct wl_listener *listener, void *data)
 }
 
 void
+<<<<<<< HEAD
 checkconstraintregion(void)
 {
 	struct wlr_pointer_constraint_v1 *constraint = active_constraint->constraint;
@@ -772,6 +907,8 @@ checkconstraintregion(void)
 }
 
 void
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 chvt(const Arg *arg)
 {
 	wlr_session_change_vt(wlr_backend_get_session(backend), arg->ui);
@@ -799,11 +936,15 @@ checkidleinhibitor(struct wlr_surface *exclude)
 void
 cleanup(void)
 {
+<<<<<<< HEAD
 	size_t i;
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 #ifdef XWAYLAND
 	wlr_xwayland_destroy(xwayland);
 #endif
 	wl_display_destroy_clients(dpy);
+<<<<<<< HEAD
 
 	/* kill child processes */
 	for (i = 0; i < autostart_len; i++) {
@@ -813,6 +954,8 @@ cleanup(void)
 		}
 	}
 
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	if (child_pid > 0) {
 		kill(child_pid, SIGTERM);
 		waitpid(child_pid, NULL, 0);
@@ -845,12 +988,19 @@ void
 cleanupmon(struct wl_listener *listener, void *data)
 {
 	Monitor *m = wl_container_of(listener, m, destroy);
+<<<<<<< HEAD
 	LayerSurface *l, *tmp;
 	int i;
 
     DwlIpcOutput *ipc_output;
     wl_list_for_each(ipc_output, &m->dwl_ipc_outputs, link)
         wl_resource_destroy(ipc_output->resource);
+=======
+	DwlWmMonitor *mon, *montmp;
+	LayerSurface *l, *tmp;
+	int i;
+
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	for (i = 0; i <= ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY; i++)
 		wl_list_for_each_safe(l, tmp, &m->layers[i], link)
 			wlr_layer_surface_v1_destroy(l->layer_surface);
@@ -860,10 +1010,20 @@ cleanupmon(struct wl_listener *listener, void *data)
 	wl_list_remove(&m->link);
 	m->wlr_output->data = NULL;
 	wlr_output_layout_remove(output_layout, m->wlr_output);
+<<<<<<< HEAD
 	wlr_scene_output_destroy(m->scene_output);
 	wlr_scene_node_destroy(&m->fullscreen_bg->node);
 
 	free(m->pertag);
+=======
+	wl_list_for_each_safe(mon, montmp, &m->dwl_wm_monitor_link, link) {
+			wl_resource_set_user_data(mon->resource, NULL);
+			free(mon);
+	}
+	wlr_scene_output_destroy(m->scene_output);
+	wlr_scene_node_destroy(&m->fullscreen_bg->node);
+
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	closemon(m);
 	free(m);
 }
@@ -943,12 +1103,15 @@ createdecoration(struct wl_listener *listener, void *data)
 }
 
 void
+<<<<<<< HEAD
 commitpointerconstraint(struct wl_listener *listener, void *data)
 {
 	checkconstraintregion();
 }
 
 void
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 createidleinhibitor(struct wl_listener *listener, void *data)
 {
 	struct wlr_idle_inhibitor_v1 *idle_inhibitor = data;
@@ -1067,19 +1230,28 @@ createmon(struct wl_listener *listener, void *data)
 	const MonitorRule *r;
 	size_t i;
 	Monitor *m = wlr_output->data = ecalloc(1, sizeof(*m));
+<<<<<<< HEAD
 	m->wlr_output = wlr_output;
 
     wl_list_init(&m->dwl_ipc_outputs);
+=======
+	wl_list_init(&m->dwl_wm_monitor_link);
+	m->wlr_output = wlr_output;
+
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	wlr_output_init_render(wlr_output, alloc, drw);
 
 	/* Initialize monitor state using configured rules */
 	for (i = 0; i < LENGTH(m->layers); i++)
 		wl_list_init(&m->layers[i]);
+<<<<<<< HEAD
 
 	m->gappih = gappih;
 	m->gappiv = gappiv;
 	m->gappoh = gappoh;
 	m->gappov = gappov;
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	m->tagset[0] = m->tagset[1] = 1;
 	for (r = monrules; r < END(monrules); r++) {
 		if (!r->name || strstr(wlr_output->name, r->name)) {
@@ -1117,6 +1289,7 @@ createmon(struct wl_listener *listener, void *data)
 	wl_list_insert(&mons, &m->link);
 	printstatus();
 
+<<<<<<< HEAD
 	m->pertag = calloc(1, sizeof(Pertag));
 	m->pertag->curtag = m->pertag->prevtag = 1;
 
@@ -1129,6 +1302,8 @@ createmon(struct wl_listener *listener, void *data)
 		m->pertag->sellts[i] = m->sellt;
 	}
 
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	/* The xdg-protocol specifies:
 	 *
 	 * If the fullscreened surface is not opaque, the compositor must make
@@ -1244,6 +1419,7 @@ createpointer(struct wlr_pointer *pointer)
 }
 
 void
+<<<<<<< HEAD
 createpointerconstraint(struct wl_listener *listener, void *data)
 {
 	struct wlr_pointer_constraint_v1 *wlr_constraint = data;
@@ -1312,6 +1488,8 @@ cursorconstrain(struct wlr_pointer_constraint_v1 *wlr_constraint)
 }
 
 void
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 cursorframe(struct wl_listener *listener, void *data)
 {
 	/* This event is forwarded by the cursor when a pointer emits an frame
@@ -1323,6 +1501,7 @@ cursorframe(struct wl_listener *listener, void *data)
 }
 
 void
+<<<<<<< HEAD
 deck(Monitor *m)
 {
 	unsigned int i, n = 0, mw, my;
@@ -1389,13 +1568,19 @@ cursorwarptoconstrainthint(void)
 }
 
 void
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 destroydragicon(struct wl_listener *listener, void *data)
 {
 	struct wlr_drag_icon *icon = data;
 	wlr_scene_node_destroy(icon->data);
 	/* Focus enter isn't sent during drag, so refocus the focused node. */
 	focusclient(focustop(selmon), 1);
+<<<<<<< HEAD
 	motionnotify(0, NULL, 0, 0, 0, 0);
+=======
+	motionnotify(0);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 }
 
 void
@@ -1430,7 +1615,11 @@ destroylock(SessionLock *lock, int unlock)
 	wlr_scene_node_set_enabled(&locked_bg->node, 0);
 
 	focusclient(focustop(selmon), 0);
+<<<<<<< HEAD
 	motionnotify(0, NULL, 0, 0, 0, 0);
+=======
+	motionnotify(0);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 
 destroy:
 	wl_list_remove(&lock->new_surface.link);
@@ -1485,6 +1674,7 @@ destroynotify(struct wl_listener *listener, void *data)
 }
 
 void
+<<<<<<< HEAD
 destroypointerconstraint(struct wl_listener *listener, void *data)
 {
 	PointerConstraint *constraint = wl_container_of(listener, constraint, destroy);
@@ -1505,6 +1695,8 @@ destroypointerconstraint(struct wl_listener *listener, void *data)
 }
 
 void
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 destroysessionlock(struct wl_listener *listener, void *data)
 {
 	SessionLock *lock = wl_container_of(listener, lock, destroy);
@@ -1534,6 +1726,7 @@ dirtomon(enum wlr_direction dir)
 	return selmon;
 }
 
+<<<<<<< HEAD
 void dwl_ipc_manager_bind(struct wl_client *client, void *data, uint32_t version, uint32_t id) {
     struct wl_resource *manager_resource = wl_resource_create(client, &zdwl_ipc_manager_v2_interface, version, id);
     if (!manager_resource) {
@@ -1696,11 +1889,17 @@ void dwl_ipc_output_release(struct wl_client *client, struct wl_resource *resour
     wl_resource_destroy(resource);
 }
 
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 void
 focusclient(Client *c, int lift)
 {
 	struct wlr_surface *old = seat->keyboard_state.focused_surface;
+<<<<<<< HEAD
 	int i, unused_lx, unused_ly, old_client_type;
+=======
+	int unused_lx, unused_ly, old_client_type;
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	Client *old_c = NULL;
 	LayerSurface *old_l = NULL;
 
@@ -1731,8 +1930,12 @@ focusclient(Client *c, int lift)
 		/* Don't change border color if there is an exclusive focus or we are
 		 * handling a drag operation */
 		if (!exclusive_focus && !seat->drag)
+<<<<<<< HEAD
 			for (i = 0; i < 4; i++)
 				wlr_scene_rect_set_color(c->border[i], focuscolor);
+=======
+			client_set_border_color(c, focuscolor);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	}
 
 	/* Deactivate old client if focus is changing */
@@ -1749,8 +1952,12 @@ focusclient(Client *c, int lift)
 		/* Don't deactivate old client if the new one wants focus, as this causes issues with winecfg
 		 * and probably other clients */
 		} else if (old_c && !client_is_unmanaged(old_c) && (!c || !client_wants_focus(c))) {
+<<<<<<< HEAD
 			for (i = 0; i < 4; i++)
 				wlr_scene_rect_set_color(old_c->border[i], bordercolor);
+=======
+			client_set_border_color(old_c, bordercolor);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 
 			client_activate_surface(old, 0);
 		}
@@ -1764,7 +1971,11 @@ focusclient(Client *c, int lift)
 	}
 
 	/* Change cursor surface */
+<<<<<<< HEAD
 	motionnotify(0, NULL, 0, 0, 0, 0);
+=======
+	motionnotify(0);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 
 	/* Have a client, so focus its top-level wlr_surface */
 	client_notify_enter(client_surface(c), wlr_seat_get_keyboard(seat));
@@ -1834,12 +2045,17 @@ void
 handlesig(int signo)
 {
 	if (signo == SIGCHLD) {
+<<<<<<< HEAD
+=======
+#ifdef XWAYLAND
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 		siginfo_t in;
 		/* wlroots expects to reap the XWayland process itself, so we
 		 * use WNOWAIT to keep the child waitable until we know it's not
 		 * XWayland.
 		 */
 		while (!waitid(P_ALL, 0, &in, WEXITED|WNOHANG|WNOWAIT) && in.si_pid
+<<<<<<< HEAD
 #ifdef XWAYLAND
 			   && (!xwayland || in.si_pid != xwayland->server->pid)
 #endif
@@ -1859,6 +2075,13 @@ handlesig(int signo)
 				}
 			}
 		}
+=======
+				&& (!xwayland || in.si_pid != xwayland->server->pid))
+			waitpid(in.si_pid, NULL, 0);
+#else
+		while (waitpid(-1, NULL, WNOHANG) > 0);
+#endif
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	} else if (signo == SIGINT || signo == SIGTERM) {
 		quit(NULL);
 	}
@@ -1869,11 +2092,16 @@ incnmaster(const Arg *arg)
 {
 	if (!arg || !selmon)
 		return;
+<<<<<<< HEAD
 	selmon->nmaster = selmon->pertag->nmasters[selmon->pertag->curtag] = MAX(selmon->nmaster + arg->i, 0);
+=======
+	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	arrange(selmon);
 }
 
 void
+<<<<<<< HEAD
 incgaps(const Arg *arg)
 {
 	setgaps(
@@ -1951,6 +2179,8 @@ incovgaps(const Arg *arg)
 }
 
 void
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 inputdevice(struct wl_listener *listener, void *data)
 {
 	/* This event is raised by the backend when a new input device becomes
@@ -1989,6 +2219,7 @@ keybinding(uint32_t mods, xkb_keysym_t sym)
 	 * processing.
 	 */
 	int handled = 0;
+<<<<<<< HEAD
 	int current = 0;
 	const Key *k;
 
@@ -2028,6 +2259,15 @@ keybinding(uint32_t mods, xkb_keysym_t sym)
 
 	if (!current) {
 		chainkey = -1;
+=======
+	const Key *k;
+	for (k = keys; k < END(keys); k++) {
+		if (CLEANMASK(mods) == CLEANMASK(k->mod) &&
+				sym == k->keysym && k->func) {
+			k->func(&k->arg);
+			handled = 1;
+		}
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	}
 	return handled;
 }
@@ -2151,7 +2391,11 @@ void
 maplayersurfacenotify(struct wl_listener *listener, void *data)
 {
 	LayerSurface *l = wl_container_of(listener, l, map);
+<<<<<<< HEAD
 	motionnotify(0, NULL, 0, 0, 0, 0);
+=======
+	motionnotify(0);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 }
 
 void
@@ -2247,12 +2491,17 @@ monocle(Monitor *m)
 	wl_list_for_each(c, &clients, link) {
 		if (!VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
 			continue;
+<<<<<<< HEAD
 		n++;
 		if (!monoclegaps)
 			resize(c, m->w, 0);
 		else
 			resize(c, (struct wlr_box){.x = m->w.x + gappoh, .y = m->w.y + gappov,
 				.width = m->w.width - 2 * gappoh, .height = m->w.height - 2 * gappov}, 0);
+=======
+		resize(c, m->w, 0);
+		n++;
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	}
 	if (n)
 		snprintf(m->ltsymbol, LENGTH(m->ltsymbol), "[%d]", n);
@@ -2270,6 +2519,7 @@ motionabsolute(struct wl_listener *listener, void *data)
 	 * so we have to warp the mouse there. There is also some hardware which
 	 * emits these events. */
 	struct wlr_pointer_motion_absolute_event *event = data;
+<<<<<<< HEAD
 	double lx, ly, dx, dy;
 	wlr_cursor_absolute_to_layout_coords(cursor, &event->pointer->base, event->x, event->y, &lx, &ly);
 	dx = lx - cursor->x;
@@ -2284,10 +2534,21 @@ motionnotify(uint32_t time, struct wlr_input_device *device, double dx, double d
 {
 	double sx = 0, sy = 0;
 	double sx_confined, sy_confined;
+=======
+	wlr_cursor_warp_absolute(cursor, &event->pointer->base, event->x, event->y);
+	motionnotify(event->time_msec);
+}
+
+void
+motionnotify(uint32_t time)
+{
+	double sx = 0, sy = 0;
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	Client *c = NULL, *w = NULL;
 	LayerSurface *l = NULL;
 	int type;
 	struct wlr_surface *surface = NULL;
+<<<<<<< HEAD
 	struct wlr_pointer_constraint_v1 *constraint = NULL;
 
 	/* Find the client under the pointer and send the event along. */
@@ -2325,6 +2586,11 @@ motionnotify(uint32_t time, struct wlr_input_device *device, double dx, double d
 		}
 		wlr_cursor_move(cursor, device, dx, dy);
 
+=======
+
+	/* time is 0 in internal calls meant to restore pointer focus. */
+	if (time) {
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 		IDLE_NOTIFY_ACTIVITY;
 
 		/* Update selmon (even while dragging a window) */
@@ -2347,6 +2613,22 @@ motionnotify(uint32_t time, struct wlr_input_device *device, double dx, double d
 		return;
 	}
 
+<<<<<<< HEAD
+=======
+	/* Find the client under the pointer and send the event along. */
+	xytonode(cursor->x, cursor->y, &surface, &c, NULL, &sx, &sy);
+
+	if (cursor_mode == CurPressed && !seat->drag) {
+		if ((type = toplevel_from_wlr_surface(
+				 seat->pointer_state.focused_surface, &w, &l)) >= 0) {
+			c = w;
+			surface = seat->pointer_state.focused_surface;
+			sx = cursor->x - (type == LayerShell ? l->geom.x : w->geom.x);
+			sy = cursor->y - (type == LayerShell ? l->geom.y : w->geom.y);
+		}
+	}
+
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	/* If there's no client surface under the cursor, set the cursor image to a
 	 * default. This is what makes the cursor image appear when you move it
 	 * off of a client or over its border. */
@@ -2367,8 +2649,13 @@ motionrelative(struct wl_listener *listener, void *data)
 	 * special configuration applied for the specific input device which
 	 * generated the event. You can pass NULL for the device if you want to move
 	 * the cursor around without any input. */
+<<<<<<< HEAD
 	motionnotify(event->time_msec, &event->pointer->base, event->delta_x, event->delta_y,
 			event->unaccel_dx, event->unaccel_dy);
+=======
+	wlr_cursor_move(cursor, &event->pointer->base, event->delta_x, event->delta_y);
+	motionnotify(event->time_msec);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 }
 
 void
@@ -2471,6 +2758,7 @@ outputmgrtest(struct wl_listener *listener, void *data)
 }
 
 void
+<<<<<<< HEAD
 pointerconstraintsetregion(struct wl_listener *listener, void *data)
 {
 	PointerConstraint *constraint = wl_container_of(listener, constraint, set_region);
@@ -2479,6 +2767,8 @@ pointerconstraintsetregion(struct wl_listener *listener, void *data)
 }
 
 void
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 pointerfocus(Client *c, struct wlr_surface *surface, double sx, double sy,
 		uint32_t time)
 {
@@ -2542,8 +2832,17 @@ printstatus(void)
 		printf("%s selmon %u\n", m->wlr_output->name, m == selmon);
 		printf("%s tags %u %u %u %u\n", m->wlr_output->name, occ, m->tagset[m->seltags],
 				sel, urg);
+<<<<<<< HEAD
 		printf("%s layout %s\n", m->wlr_output->name, m->ltsymbol);
         dwl_ipc_output_printstatus(m);
+=======
+<<<<<<< HEAD
+		printf("%s layout %s\n", m->wlr_output->name, m->lt[m->sellt]->symbol);
+		dwl_wm_printstatus(m);
+=======
+		printf("%s layout %s\n", m->wlr_output->name, m->ltsymbol);
+>>>>>>> bbdf2a9 (display clients count in monocle symbol)
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	}
 	fflush(stdout);
 }
@@ -2627,7 +2926,10 @@ run(char *startup_cmd)
 		die("startup: backend_start");
 
 	/* Now that the socket exists and the backend is started, run the startup command */
+<<<<<<< HEAD
 	autostartexec();
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	if (startup_cmd) {
 		int piperw[2];
 		if (pipe(piperw) < 0)
@@ -2690,7 +2992,14 @@ void
 setfloating(Client *c, int floating)
 {
 	c->isfloating = floating;
+<<<<<<< HEAD
 	wlr_scene_node_reparent(&c->scene->node, layers[c->isfloating ? LyrFloat : LyrTile]);
+=======
+	if (!c->mon)
+		return;
+	wlr_scene_node_reparent(&c->scene->node, layers[c->isfullscreen
+			? LyrFS : c->isfloating ? LyrFloat : LyrTile]);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	arrange(c->mon);
 	printstatus();
 }
@@ -2703,7 +3012,11 @@ setfullscreen(Client *c, int fullscreen)
 		return;
 	c->bw = fullscreen ? 0 : borderpx;
 	client_set_fullscreen(c, fullscreen);
+<<<<<<< HEAD
 	wlr_scene_node_reparent(&c->scene->node, layers[fullscreen
+=======
+	wlr_scene_node_reparent(&c->scene->node, layers[c->isfullscreen
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 			? LyrFS : c->isfloating ? LyrFloat : LyrTile]);
 
 	if (fullscreen) {
@@ -2719,6 +3032,7 @@ setfullscreen(Client *c, int fullscreen)
 }
 
 void
+<<<<<<< HEAD
 setgaps(int oh, int ov, int ih, int iv)
 {
 	selmon->gappoh = MAX(oh, 0);
@@ -2729,14 +3043,22 @@ setgaps(int oh, int ov, int ih, int iv)
 }
 
 void
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 setlayout(const Arg *arg)
 {
 	if (!selmon)
 		return;
 	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
+<<<<<<< HEAD
 		selmon->sellt = selmon->pertag->sellts[selmon->pertag->curtag] ^= 1;
 	if (arg && arg->v)
 		selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt] = (Layout *)arg->v;
+=======
+		selmon->sellt ^= 1;
+	if (arg && arg->v)
+		selmon->lt[selmon->sellt] = (Layout *)arg->v;
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, LENGTH(selmon->ltsymbol));
 	arrange(selmon);
 	printstatus();
@@ -2753,7 +3075,11 @@ setmfact(const Arg *arg)
 	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
 	if (f < 0.1 || f > 0.9)
 		return;
+<<<<<<< HEAD
 	selmon->mfact = selmon->pertag->mfacts[selmon->pertag->curtag] = f;
+=======
+	selmon->mfact = f;
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	arrange(selmon);
 }
 
@@ -2775,6 +3101,10 @@ setmon(Client *c, Monitor *m, uint32_t newtags)
 		resize(c, c->geom, 0);
 		c->tags = newtags ? newtags : m->tagset[m->seltags]; /* assign tags of target monitor */
 		setfullscreen(c, c->isfullscreen); /* This will call arrange(c->mon) */
+<<<<<<< HEAD
+=======
+		setfloating(c, c->isfloating);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	}
 	focusclient(focustop(selmon), 1);
 }
@@ -2811,6 +3141,11 @@ setup(void)
 	for (i = 0; i < LENGTH(sig); i++)
 		sigaction(sig[i], &sa, NULL);
 
+<<<<<<< HEAD
+=======
+	wlr_log_init(log_level, NULL);
+
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	/* The Wayland display is managed by libwayland. It handles accepting
 	 * clients from the Unix socket, manging Wayland globals, and so on. */
 	dpy = wl_display_create();
@@ -2964,6 +3299,7 @@ setup(void)
 	wl_signal_add(&output_mgr->events.apply, &output_mgr_apply);
 	wl_signal_add(&output_mgr->events.test, &output_mgr_test);
 
+<<<<<<< HEAD
 	relative_pointer_mgr = wlr_relative_pointer_manager_v1_create(dpy);
 	pointer_constraints = wlr_pointer_constraints_v1_create(dpy);
 	wl_signal_add(&pointer_constraints->events.new_constraint, &new_pointer_constraint);
@@ -2971,6 +3307,10 @@ setup(void)
 
 	wlr_scene_set_presentation(scene, wlr_presentation_create(dpy, backend));
     wl_global_create(dpy, &zdwl_ipc_manager_v2_interface, 2, NULL, dwl_ipc_manager_bind);
+=======
+	wlr_scene_set_presentation(scene, wlr_presentation_create(dpy, backend));
+	wl_global_create(dpy, &znet_tapesoftware_dwl_wm_v1_interface, 1, NULL, dwl_wm_bind);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 
 #ifdef XWAYLAND
 	/*
@@ -3008,7 +3348,10 @@ startdrag(struct wl_listener *listener, void *data)
 		return;
 
 	drag->icon->data = &wlr_scene_subsurface_tree_create(drag_icon, drag->icon->surface)->node;
+<<<<<<< HEAD
 	motionnotify(0, NULL, 0, 0, 0, 0);
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	wl_signal_add(&drag->icon->events.destroy, &drag_icon_destroy);
 }
 
@@ -3036,7 +3379,11 @@ tagmon(const Arg *arg)
 void
 tile(Monitor *m)
 {
+<<<<<<< HEAD
 	unsigned int i, n = 0, h, r, oe = enablegaps, ie = enablegaps, mw, my, ty;
+=======
+	unsigned int i, n = 0, mw, my, ty;
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	Client *c;
 
 	wl_list_for_each(c, &clients, link)
@@ -3044,6 +3391,7 @@ tile(Monitor *m)
 			n++;
 	if (n == 0)
 		return;
+<<<<<<< HEAD
 	
 	if (smartgaps == n) {
 		oe = 0; // outer gaps disabled
@@ -3055,10 +3403,19 @@ tile(Monitor *m)
 		mw = m->w.width - 2*m->gappov*oe + m->gappiv*ie;
 	i = 0;
 	my = ty = m->gappoh*oe;
+=======
+
+	if (n > m->nmaster)
+		mw = m->nmaster ? m->w.width * m->mfact : 0;
+	else
+		mw = m->w.width;
+	i = my = ty = 0;
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	wl_list_for_each(c, &clients, link) {
 		if (!VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
 			continue;
 		if (i < m->nmaster) {
+<<<<<<< HEAD
 			r = MIN(n, m->nmaster) - i;
 			h = (m->w.height - my - m->gappoh*oe - m->gappih*ie * (r - 1)) / r;
 			resize(c, (struct wlr_box){.x = m->w.x + m->gappov*oe, .y = m->w.y + my,
@@ -3070,6 +3427,15 @@ tile(Monitor *m)
 			resize(c, (struct wlr_box){.x = m->w.x + mw + m->gappov*oe, .y = m->w.y + ty,
 				.width = m->w.width - mw - 2*m->gappov*oe, .height = h}, 0);
 			ty += c->geom.height + m->gappih*ie;
+=======
+			resize(c, (struct wlr_box){.x = m->w.x, .y = m->w.y + my, .width = mw,
+				.height = (m->w.height - my) / (MIN(n, m->nmaster) - i)}, 0);
+			my += c->geom.height;
+		} else {
+			resize(c, (struct wlr_box){.x = m->w.x + mw, .y = m->w.y + ty,
+				.width = m->w.width - mw, .height = (m->w.height - ty) / (n - i)}, 0);
+			ty += c->geom.height;
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 		}
 		i++;
 	}
@@ -3093,6 +3459,7 @@ togglefullscreen(const Arg *arg)
 }
 
 void
+<<<<<<< HEAD
 togglegaps(const Arg *arg)
 {
 	enablegaps = !enablegaps;
@@ -3100,6 +3467,8 @@ togglegaps(const Arg *arg)
 }
 
 void
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 toggletag(const Arg *arg)
 {
 	uint32_t newtags;
@@ -3120,11 +3489,15 @@ void
 toggleview(const Arg *arg)
 {
 	uint32_t newtagset = selmon ? selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK) : 0;
+<<<<<<< HEAD
 	size_t i;
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 
 	if (!newtagset)
 		return;
 
+<<<<<<< HEAD
 	if (newtagset == ~0) {
 		selmon->pertag->prevtag = selmon->pertag->curtag;
 		selmon->pertag->curtag = 0;
@@ -3144,18 +3517,23 @@ toggleview(const Arg *arg)
 	selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
 	selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
 
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	selmon->tagset[selmon->seltags] = newtagset;
 	focusclient(focustop(selmon), 1);
 	arrange(selmon);
 	printstatus();
 }
 
+<<<<<<< HEAD
 void toggle_visibility(const Arg *arg) {
     DwlIpcOutput *ipc_output;
     wl_list_for_each(ipc_output, &selmon->dwl_ipc_outputs, link)
         zdwl_ipc_output_v2_send_toggle_visibility(ipc_output->resource);
 }
 
+=======
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 void
 unlocksession(struct wl_listener *listener, void *data)
 {
@@ -3178,7 +3556,11 @@ unmaplayersurfacenotify(struct wl_listener *listener, void *data)
 	if (layersurface->layer_surface->surface ==
 			seat->keyboard_state.focused_surface)
 		focusclient(focustop(selmon), 1);
+<<<<<<< HEAD
 	motionnotify(0, NULL, 0, 0, 0, 0);
+=======
+	motionnotify(0);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 }
 
 void
@@ -3205,7 +3587,11 @@ unmapnotify(struct wl_listener *listener, void *data)
 	wl_list_remove(&c->commit.link);
 	wlr_scene_node_destroy(&c->scene->node);
 	printstatus();
+<<<<<<< HEAD
 	motionnotify(0, NULL, 0, 0, 0, 0);
+=======
+	motionnotify(0);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 }
 
 void
@@ -3312,6 +3698,10 @@ urgent(struct wl_listener *listener, void *data)
 	if (!c || c == focustop(selmon))
 		return;
 
+<<<<<<< HEAD
+=======
+	client_set_border_color(c, urgentcolor);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	c->isurgent = 1;
 	printstatus();
 }
@@ -3319,6 +3709,7 @@ urgent(struct wl_listener *listener, void *data)
 void
 view(const Arg *arg)
 {
+<<<<<<< HEAD
 	size_t i, tmptag;
 
 	if (!selmon || (arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
@@ -3346,6 +3737,13 @@ view(const Arg *arg)
 	selmon->lt[selmon->sellt] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt];
 	selmon->lt[selmon->sellt^1] = selmon->pertag->ltidxs[selmon->pertag->curtag][selmon->sellt^1];
 
+=======
+	if (!selmon || (arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
+		return;
+	selmon->seltags ^= 1; /* toggle sel tagset */
+	if (arg->ui & TAGMASK)
+		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	focusclient(focustop(selmon), 1);
 	arrange(selmon);
 	printstatus();
@@ -3476,10 +3874,17 @@ createnotifyx11(struct wl_listener *listener, void *data)
 	LISTEN(&xsurface->events.request_fullscreen, &c->fullscreen, fullscreennotify);
 }
 
+<<<<<<< HEAD
 Atom
 getatom(xcb_connection_t *xc, const char *name)
 {
 	Atom atom = 0;
+=======
+xcb_atom_t
+getatom(xcb_connection_t *xc, const char *name)
+{
+	xcb_atom_t atom = 0;
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	xcb_intern_atom_reply_t *reply;
 	xcb_intern_atom_cookie_t cookie = xcb_intern_atom(xc, 0, strlen(name), name);
 	if ((reply = xcb_intern_atom_reply(xc, cookie, NULL)))
@@ -3497,6 +3902,13 @@ sethints(struct wl_listener *listener, void *data)
 		return;
 
 	c->isurgent = xcb_icccm_wm_hints_get_urgency(c->surface.xwayland->hints);
+<<<<<<< HEAD
+=======
+
+	if (c->isurgent && client_is_mapped(c))
+		client_set_border_color(c, urgentcolor);
+
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	printstatus();
 }
 
@@ -3538,9 +3950,17 @@ main(int argc, char *argv[])
 	char *startup_cmd = NULL;
 	int c;
 
+<<<<<<< HEAD
 	while ((c = getopt(argc, argv, "s:hv")) != -1) {
 		if (c == 's')
 			startup_cmd = optarg;
+=======
+	while ((c = getopt(argc, argv, "s:hdv")) != -1) {
+		if (c == 's')
+			startup_cmd = optarg;
+		else if (c == 'd')
+			log_level = WLR_DEBUG;
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 		else if (c == 'v')
 			die("dwl " VERSION);
 		else
@@ -3558,6 +3978,7 @@ main(int argc, char *argv[])
 	return EXIT_SUCCESS;
 
 usage:
+<<<<<<< HEAD
 	die("Usage: %s [-v] [-s startup command]", argv[0]);
 }
 
@@ -3600,10 +4021,30 @@ bstack(Monitor *m)
 				tx += c->geom.width;
 		}
 		i++;
+=======
+	die("Usage: %s [-v] [-d] [-s startup command]", argv[0]);
+}
+
+/* dwl_wm_monitor_v1 */
+static void
+dwl_wm_monitor_handle_release(struct wl_client *client, struct wl_resource *resource)
+{
+	wl_resource_destroy(resource);
+}
+
+static void
+dwl_wm_monitor_handle_destroy(struct wl_resource *resource)
+{
+	DwlWmMonitor *mon = wl_resource_get_user_data(resource);
+	if (mon) {
+		wl_list_remove(&mon->link);
+		free(mon);
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 	}
 }
 
 static void
+<<<<<<< HEAD
 bstackhoriz(Monitor *m) {
 	int w, mh, mx, tx, ty, th;
 	unsigned int i, n = 0;
@@ -3641,3 +4082,176 @@ bstackhoriz(Monitor *m) {
 		i++;
 	}
 }
+=======
+dwl_wm_printstatus_to(Monitor *m, const DwlWmMonitor *mon)
+{
+	Client *c, *focused;
+	int tagmask, state, numclients, focused_client;
+	focused = focustop(m);
+	znet_tapesoftware_dwl_wm_monitor_v1_send_selected(mon->resource, m == selmon);
+
+	for (int tag = 0; tag<LENGTH(tags); tag++) {
+		numclients = state = 0;
+		focused_client = -1;
+		tagmask = 1 << tag;
+		if ((tagmask & m->tagset[m->seltags]) != 0)
+			state = state | ZNET_TAPESOFTWARE_DWL_WM_MONITOR_V1_TAG_STATE_ACTIVE;
+		wl_list_for_each(c, &clients, link) {
+			if (c->mon != m)
+				continue;
+			if (!(c->tags & tagmask))
+				continue;
+			if (c == focused)
+				focused_client = numclients;
+			numclients++;
+			if (c->isurgent)
+				state = state | ZNET_TAPESOFTWARE_DWL_WM_MONITOR_V1_TAG_STATE_URGENT;
+		}
+		znet_tapesoftware_dwl_wm_monitor_v1_send_tag(mon->resource,
+			tag, state, numclients, focused_client);
+	}
+	znet_tapesoftware_dwl_wm_monitor_v1_send_layout(mon->resource, m->lt[m->sellt] - layouts);
+	znet_tapesoftware_dwl_wm_monitor_v1_send_title(mon->resource,
+		focused ? client_get_title(focused) : "");
+	znet_tapesoftware_dwl_wm_monitor_v1_send_frame(mon->resource);
+}
+
+static void
+dwl_wm_printstatus(Monitor *m)
+{
+	DwlWmMonitor *mon;
+	wl_list_for_each(mon, &m->dwl_wm_monitor_link, link) {
+		dwl_wm_printstatus_to(m, mon);
+	}
+}
+
+static void
+dwl_wm_monitor_handle_set_tags(struct wl_client *client, struct wl_resource *resource,
+	uint32_t t, uint32_t toggle_tagset)
+{
+	DwlWmMonitor *mon;
+	Monitor *m;
+	mon = wl_resource_get_user_data(resource);
+	if (!mon)
+		return;
+	m = mon->monitor;
+	if ((t & TAGMASK) == m->tagset[m->seltags])
+		return;
+	if (toggle_tagset)
+		m->seltags ^= 1;
+	if (t & TAGMASK)
+		m->tagset[m->seltags] = t & TAGMASK;
+
+	focusclient(focustop(m), 1);
+	arrange(m);
+	printstatus();
+}
+
+static void
+dwl_wm_monitor_handle_set_layout(struct wl_client *client, struct wl_resource *resource,
+	uint32_t layout)
+{
+	DwlWmMonitor *mon;
+	Monitor *m;
+	mon = wl_resource_get_user_data(resource);
+	if (!mon)
+		return;
+	m = mon->monitor;
+	if (layout >= LENGTH(layouts))
+		return;
+	if (layout != m->lt[m->sellt] - layouts)
+		m->sellt ^= 1;
+
+	m->lt[m->sellt] = &layouts[layout];
+	arrange(m);
+	printstatus();
+}
+
+static void
+dwl_wm_monitor_handle_set_client_tags(struct wl_client *client, struct wl_resource *resource,
+	uint32_t and, uint32_t xor)
+{
+	DwlWmMonitor *mon;
+	Client *sel;
+	unsigned int newtags;
+	mon = wl_resource_get_user_data(resource);
+	if (!mon)
+		return;
+	sel = focustop(mon->monitor);
+	if (!sel)
+		return;
+	newtags = (sel->tags & and) ^ xor;
+	if (newtags) {
+		sel->tags = newtags;
+		focusclient(focustop(selmon), 1);
+		arrange(selmon);
+		printstatus();
+	}
+}
+
+static const struct znet_tapesoftware_dwl_wm_monitor_v1_interface dwl_wm_monitor_implementation = {
+	.release = dwl_wm_monitor_handle_release,
+	.set_tags = dwl_wm_monitor_handle_set_tags,
+	.set_layout = dwl_wm_monitor_handle_set_layout,
+	.set_client_tags = dwl_wm_monitor_handle_set_client_tags,
+};
+
+/* dwl_wm_v1 */
+static void
+dwl_wm_handle_release(struct wl_client *client, struct wl_resource *resource)
+{
+	wl_resource_destroy(resource);
+}
+
+static void
+dwl_wm_handle_get_monitor(struct wl_client *client, struct wl_resource *resource,
+	uint32_t id, struct wl_resource *output)
+{
+	DwlWmMonitor *dwl_wm_monitor;
+	struct wlr_output *wlr_output = wlr_output_from_resource(output);
+	struct Monitor *m = wlr_output->data;
+	struct wl_resource *dwlOutputResource = wl_resource_create(client,
+		&znet_tapesoftware_dwl_wm_monitor_v1_interface, wl_resource_get_version(resource), id);
+	if (!resource) {
+		wl_client_post_no_memory(client);
+		return;
+	}
+	dwl_wm_monitor = calloc(1, sizeof(DwlWmMonitor));
+	dwl_wm_monitor->resource = dwlOutputResource;
+	dwl_wm_monitor->monitor = m;
+	wl_resource_set_implementation(dwlOutputResource, &dwl_wm_monitor_implementation,
+	dwl_wm_monitor, dwl_wm_monitor_handle_destroy);
+	wl_list_insert(&m->dwl_wm_monitor_link, &dwl_wm_monitor->link);
+	dwl_wm_printstatus_to(m, dwl_wm_monitor);
+}
+
+static void
+dwl_wm_handle_destroy(struct wl_resource *resource)
+{
+	/* no state to destroy */
+}
+
+static const struct znet_tapesoftware_dwl_wm_v1_interface dwl_wm_implementation = {
+	.release = dwl_wm_handle_release,
+	.get_monitor = dwl_wm_handle_get_monitor,
+};
+
+static void
+dwl_wm_bind(struct wl_client *client, void *data,
+	uint32_t version, uint32_t id)
+{
+	struct wl_resource *resource = wl_resource_create(client,
+		&znet_tapesoftware_dwl_wm_v1_interface, version, id);
+	if (!resource) {
+		wl_client_post_no_memory(client);
+		return;
+	}
+
+	wl_resource_set_implementation(resource, &dwl_wm_implementation, NULL, dwl_wm_handle_destroy);
+
+	for (int i = 0; i < LENGTH(tags); i++)
+		znet_tapesoftware_dwl_wm_v1_send_tag(resource, tags[i]);
+	for (int i = 0; i < LENGTH(layouts); i++)
+		znet_tapesoftware_dwl_wm_v1_send_layout(resource, layouts[i].symbol);
+}
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
diff --git a/dwl.desktop b/dwl.desktop
index ae5e6dc..1838bd2 100644
--- a/dwl.desktop
+++ b/dwl.desktop
@@ -1,5 +1,11 @@
 [Desktop Entry]
+<<<<<<< HEAD
 Name=DWL
 Comment=dwm for Wayland
 Exec=dbus-run-session dwl
+=======
+Name=dwl
+Comment=dwm for Wayland
+Exec=dwl
+>>>>>>> cadf5eb1e9ee1737789548130947852ba2edf0da
 Type=Application
diff --git a/main...madcowog ipc-bbdf2.patch b/main...madcowog ipc-bbdf2.patch
new file mode 100644
index 0000000..7963bf8
--- /dev/null
+++ b/main...madcowog ipc-bbdf2.patch	
@@ -0,0 +1,559 @@
+From 8b479b440d95b8deb97ff852c1c44ab4b21270fa Mon Sep 17 00:00:00 2001
+From: MadcowOG <N/A>
+Date: Wed, 26 Apr 2023 15:26:21 -0700
+Subject: [PATCH] Implemented dwl-ipc
+
+---
+ Makefile                          |  13 +-
+ config.def.h                      |   1 +
+ dwl.c                             | 212 +++++++++++++++++++++++++++++-
+ protocols/dwl-ipc-unstable-v1.xml | 183 ++++++++++++++++++++++++++
+ 4 files changed, 405 insertions(+), 4 deletions(-)
+ create mode 100644 protocols/dwl-ipc-unstable-v1.xml
+
+diff --git a/Makefile b/Makefile
+index ccca0794..6e2d4fa1 100644
+--- a/Makefile
++++ b/Makefile
+@@ -14,10 +14,11 @@ DWLCFLAGS = `$(PKG_CONFIG) --cflags $(PKGS)` $(DWLCPPFLAGS) $(DWLDEVCFLAGS) $(CF
+ LDLIBS    = `$(PKG_CONFIG) --libs $(PKGS)` $(LIBS)
+ 
+ all: dwl
+-dwl: dwl.o util.o
+-	$(CC) dwl.o util.o $(LDLIBS) $(LDFLAGS) $(DWLCFLAGS) -o $@
+-dwl.o: dwl.c config.mk config.h client.h xdg-shell-protocol.h wlr-layer-shell-unstable-v1-protocol.h
++dwl: dwl.o util.o dwl-ipc-unstable-v1-protocol.o
++	$(CC) dwl.o util.o dwl-ipc-unstable-v1-protocol.o -g $(LDLIBS) $(LDFLAGS) $(DWLCFLAGS) -o $@
++dwl.o: dwl.c config.mk config.h client.h xdg-shell-protocol.h wlr-layer-shell-unstable-v1-protocol.h dwl-ipc-unstable-v1-protocol.o
+ util.o: util.c util.h
++dwl-ipc-unstable-v1-protocol.o: dwl-ipc-unstable-v1-protocol.h
+ 
+ # wayland-scanner is a tool which generates C headers and rigging for Wayland
+ # protocols, which are specified in XML. wlroots requires you to rig these up
+@@ -31,6 +32,12 @@ xdg-shell-protocol.h:
+ wlr-layer-shell-unstable-v1-protocol.h:
+ 	$(WAYLAND_SCANNER) server-header \
+ 		protocols/wlr-layer-shell-unstable-v1.xml $@
++dwl-ipc-unstable-v1-protocol.h:
++	$(WAYLAND_SCANNER) server-header \
++		protocols/dwl-ipc-unstable-v1.xml $@
++dwl-ipc-unstable-v1-protocol.c:
++	$(WAYLAND_SCANNER) private-code \
++		protocols/dwl-ipc-unstable-v1.xml $@
+ 
+ config.h:
+ 	cp config.def.h $@
+diff --git a/config.def.h b/config.def.h
+index c6a49504..2b4b29f8 100644
+--- a/config.def.h
++++ b/config.def.h
+@@ -111,6 +111,7 @@ static const Key keys[] = {
+ 	/* modifier                  key                 function        argument */
+ 	{ MODKEY,                    XKB_KEY_p,          spawn,          {.v = menucmd} },
+ 	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Return,     spawn,          {.v = termcmd} },
++    { MODKEY,                    XKB_KEY_b,          toggle_visibility, {0}},
+ 	{ MODKEY,                    XKB_KEY_j,          focusstack,     {.i = +1} },
+ 	{ MODKEY,                    XKB_KEY_k,          focusstack,     {.i = -1} },
+ 	{ MODKEY,                    XKB_KEY_i,          incnmaster,     {.i = +1} },
+diff --git a/dwl.c b/dwl.c
+index b7436bb4..ebbcb501 100644
+--- a/dwl.c
++++ b/dwl.c
+@@ -58,6 +58,7 @@
+ #include <xcb/xcb_icccm.h>
+ #endif
+ 
++#include "dwl-ipc-unstable-v1-protocol.h"
+ #include "util.h"
+ 
+ /* macros */
+@@ -128,6 +129,12 @@ typedef struct {
+ 	uint32_t resize; /* configure serial of a pending resize */
+ } Client;
+ 
++typedef struct {
++    struct wl_list link;
++    struct wl_resource *resource;
++    Monitor *monitor;
++} DwlIpcOutput;
++
+ typedef struct {
+ 	uint32_t mod;
+ 	xkb_keysym_t keysym;
+@@ -174,6 +181,7 @@ typedef struct {
+ 
+ struct Monitor {
+ 	struct wl_list link;
++    struct wl_list dwl_ipc_outputs;
+ 	struct wlr_output *wlr_output;
+ 	struct wlr_scene_output *scene_output;
+ 	struct wlr_scene_rect *fullscreen_bg; /* See createmon() for info */
+@@ -255,6 +263,17 @@ static void destroynotify(struct wl_listener *listener, void *data);
+ static void destroysessionlock(struct wl_listener *listener, void *data);
+ static void destroysessionmgr(struct wl_listener *listener, void *data);
+ static Monitor *dirtomon(enum wlr_direction dir);
++static void dwl_ipc_manager_bind(struct wl_client *client, void *data, uint32_t version, uint32_t id);
++static void dwl_ipc_manager_destroy(struct wl_resource *resource);
++static void dwl_ipc_manager_get_output(struct wl_client *client, struct wl_resource *resource, uint32_t id, struct wl_resource *output);
++static void dwl_ipc_manager_release(struct wl_client *client, struct wl_resource *resource);
++static void dwl_ipc_output_destroy(struct wl_resource *resource);
++static void dwl_ipc_output_printstatus(Monitor *monitor);
++static void dwl_ipc_output_printstatus_to(DwlIpcOutput *ipc_output);
++static void dwl_ipc_output_set_client_tags(struct wl_client *client, struct wl_resource *resource, uint32_t and_tags, uint32_t xor_tags);
++static void dwl_ipc_output_set_layout(struct wl_client *client, struct wl_resource *resource, uint32_t index);
++static void dwl_ipc_output_set_tag(struct wl_client *client, struct wl_resource *resource, uint32_t tagmask, uint32_t toggle_tagset);
++static void dwl_ipc_output_release(struct wl_client *client, struct wl_resource *resource);
+ static void focusclient(Client *c, int lift);
+ static void focusmon(const Arg *arg);
+ static void focusstack(const Arg *arg);
+@@ -306,6 +325,7 @@ static void togglefloating(const Arg *arg);
+ static void togglefullscreen(const Arg *arg);
+ static void toggletag(const Arg *arg);
+ static void toggleview(const Arg *arg);
++static void toggle_visibility(const Arg *arg);
+ static void unlocksession(struct wl_listener *listener, void *data);
+ static void unmaplayersurfacenotify(struct wl_listener *listener, void *data);
+ static void unmapnotify(struct wl_listener *listener, void *data);
+@@ -371,6 +391,8 @@ static struct wl_listener cursor_frame = {.notify = cursorframe};
+ static struct wl_listener cursor_motion = {.notify = motionrelative};
+ static struct wl_listener cursor_motion_absolute = {.notify = motionabsolute};
+ static struct wl_listener drag_icon_destroy = {.notify = destroydragicon};
++static struct zdwl_ipc_manager_v1_interface dwl_ipc_manager_implementation = { .release = dwl_ipc_manager_release, .get_output = dwl_ipc_manager_get_output };
++static struct zdwl_ipc_output_v1_interface dwl_ipc_output_implementation = { .release = dwl_ipc_output_release, .set_tags = dwl_ipc_output_set_tag, .set_layout = dwl_ipc_output_set_layout, .set_client_tags = dwl_ipc_output_set_client_tags };
+ static struct wl_listener idle_inhibitor_create = {.notify = createidleinhibitor};
+ static struct wl_listener idle_inhibitor_destroy = {.notify = destroyidleinhibitor};
+ static struct wl_listener layout_change = {.notify = updatemons};
+@@ -685,12 +707,15 @@ void
+ cleanupmon(struct wl_listener *listener, void *data)
+ {
+ 	Monitor *m = wl_container_of(listener, m, destroy);
++    DwlIpcOutput *ipc_output, *ipc_tmp;
+ 	LayerSurface *l, *tmp;
+ 	int i;
+ 
+ 	for (i = 0; i <= ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY; i++)
+ 		wl_list_for_each_safe(l, tmp, &m->layers[i], link)
+ 			wlr_layer_surface_v1_destroy(l->layer_surface);
++    wl_list_for_each_safe(ipc_output, ipc_tmp, &m->dwl_ipc_outputs, link)
++        wl_resource_destroy(ipc_output->resource);
+ 
+ 	wl_list_remove(&m->destroy.link);
+ 	wl_list_remove(&m->frame.link);
+@@ -905,6 +930,7 @@ createmon(struct wl_listener *listener, void *data)
+ 	Monitor *m = wlr_output->data = ecalloc(1, sizeof(*m));
+ 	m->wlr_output = wlr_output;
+ 
++    wl_list_init(&m->dwl_ipc_outputs);
+ 	wlr_output_init_render(wlr_output, alloc, drw);
+ 
+ 	/* Initialize monitor state using configured rules */
+@@ -1045,7 +1071,7 @@ createpointer(struct wlr_pointer *pointer)
+ 
+ 		if (libinput_device_config_scroll_get_methods(libinput_device) != LIBINPUT_CONFIG_SCROLL_NO_SCROLL)
+ 			libinput_device_config_scroll_set_method (libinput_device, scroll_method);
+-		
++
+ 		if (libinput_device_config_click_get_methods(libinput_device) != LIBINPUT_CONFIG_CLICK_METHOD_NONE)
+ 			libinput_device_config_click_set_method (libinput_device, click_method);
+ 
+@@ -1197,6 +1223,182 @@ dirtomon(enum wlr_direction dir)
+ 	return selmon;
+ }
+ 
++void dwl_ipc_manager_bind(struct wl_client *client, void *data, uint32_t version, uint32_t id) {
++    int i;
++    struct wl_resource *resource = wl_resource_create(client, &zdwl_ipc_manager_v1_interface, version, id);
++    if (!resource) {
++        wl_client_post_no_memory(client);
++        return;
++    }
++    wl_resource_set_implementation(resource, &dwl_ipc_manager_implementation, NULL, dwl_ipc_manager_destroy);
++
++    for (i = 0; i < LENGTH(tags); i++)
++        zdwl_ipc_manager_v1_send_tag(resource, tags[i]);
++
++    for (i = 0; i < LENGTH(layouts); i++)
++        zdwl_ipc_manager_v1_send_layout(resource, layouts[i].symbol);
++}
++
++void dwl_ipc_manager_destroy(struct wl_resource *resource) {
++    /* No state to destroy */
++}
++
++void dwl_ipc_manager_get_output(struct wl_client *client, struct wl_resource *resource, uint32_t id, struct wl_resource *output) {
++    DwlIpcOutput *ipc_output;
++    Monitor *monitor = wlr_output_from_resource(output)->data;
++    struct wl_resource *output_resource = wl_resource_create(client, &zdwl_ipc_output_v1_interface, wl_resource_get_version(resource), id);
++    if (!resource) {
++        wl_client_post_no_memory(client);
++        return;
++    }
++
++    ipc_output = ecalloc(1, sizeof(*ipc_output));
++    ipc_output->resource = output_resource;
++    ipc_output->monitor = monitor;
++
++    wl_resource_set_implementation(output_resource, &dwl_ipc_output_implementation, ipc_output, dwl_ipc_output_destroy);
++    wl_list_insert(&monitor->dwl_ipc_outputs, &ipc_output->link);
++    dwl_ipc_output_printstatus_to(ipc_output);
++}
++
++void dwl_ipc_manager_release(struct wl_client *client, struct wl_resource *resource) {
++    wl_resource_destroy(resource);
++}
++
++void dwl_ipc_output_destroy(struct wl_resource *resource) {
++    DwlIpcOutput *ipc_output = wl_resource_get_user_data(resource);
++    if (!ipc_output)
++        return;
++
++    wl_list_remove(&ipc_output->link);
++    free(ipc_output);
++}
++
++void dwl_ipc_output_printstatus(Monitor *monitor) {
++    DwlIpcOutput *ipc_output;
++    wl_list_for_each(ipc_output, &monitor->dwl_ipc_outputs, link)
++        dwl_ipc_output_printstatus_to(ipc_output);
++}
++
++void dwl_ipc_output_printstatus_to(DwlIpcOutput *ipc_output) {
++    Monitor *monitor = ipc_output->monitor;
++    Client *c, *focused;
++    int tagmask, state, numclients, focused_client, tag;
++    const char *title, *appid;
++    focused = focustop(monitor);
++    zdwl_ipc_output_v1_send_active(ipc_output->resource, monitor == selmon);
++
++    for ( tag = 0 ; tag < LENGTH(tags); tag++) {
++        numclients = state = focused_client = 0;
++        tagmask = 1 << tag;
++        if ((tagmask & monitor->tagset[monitor->seltags]) != 0)
++            state |= ZDWL_IPC_OUTPUT_V1_TAG_STATE_ACTIVE;
++
++        wl_list_for_each(c, &clients, link) {
++            if (c->mon != monitor)
++                continue;
++            if (!(c->tags & tagmask))
++                continue;
++            if (c == focused)
++                focused_client = 1;
++            if (c->isurgent)
++                state |= ZDWL_IPC_OUTPUT_V1_TAG_STATE_URGENT;
++
++            numclients++;
++        }
++        zdwl_ipc_output_v1_send_tag(ipc_output->resource, tag, state, numclients, focused_client);
++    }
++    title = focused ? client_get_title(focused) : "";
++
++    zdwl_ipc_output_v1_send_layout(ipc_output->resource, monitor->lt[monitor->sellt] - layouts);
++    zdwl_ipc_output_v1_send_title(ipc_output->resource, title ? title : broken);
++    if (wl_resource_get_version(ipc_output->resource) >= ZDWL_IPC_OUTPUT_V1_APPID_SINCE_VERSION) { /* Don't break clients using version 1 */
++        appid = focused ? client_get_appid(focused) : "";
++        zdwl_ipc_output_v1_send_appid(ipc_output->resource, appid ? appid : broken);
++    }
++    if (wl_resource_get_version(ipc_output->resource) >= ZDWL_IPC_OUTPUT_V1_LAYOUT_SYMBOL_SINCE_VERSION) /* Don't break clients using version 2 or below */
++        zdwl_ipc_output_v1_send_layout_symbol(ipc_output->resource, monitor->ltsymbol);
++    if (wl_resource_get_version(ipc_output->resource) >= ZDWL_IPC_OUTPUT_V1_FULLSCREEN_SINCE_VERSION) {
++        zdwl_ipc_output_v1_send_fullscreen(ipc_output->resource, focused ? focused->isfullscreen : 0);
++    }
++    if (wl_resource_get_version(ipc_output->resource) >= ZDWL_IPC_OUTPUT_V1_FLOATING_SINCE_VERSION) {
++        zdwl_ipc_output_v1_send_floating(ipc_output->resource, focused ? focused->isfloating : 0);
++    }
++    zdwl_ipc_output_v1_send_frame(ipc_output->resource);
++}
++
++void dwl_ipc_output_set_client_tags(struct wl_client *client, struct wl_resource *resource, uint32_t and_tags, uint32_t xor_tags) {
++    DwlIpcOutput *ipc_output;
++    Client *selected_client;
++    unsigned int newtags;
++
++    ipc_output = wl_resource_get_user_data(resource);
++    if (!ipc_output)
++        return;
++
++    selected_client = focustop(ipc_output->monitor);
++    if (!selected_client)
++        return;
++
++    newtags = (selected_client->tags & and_tags) ^ xor_tags;
++    if (!newtags)
++        return;
++
++    selected_client->tags = newtags;
++    focusclient(focustop(selmon), 1);
++    arrange(selmon);
++    printstatus();
++}
++
++void dwl_ipc_output_set_layout(struct wl_client *client, struct wl_resource *resource, uint32_t index) {
++    DwlIpcOutput *ipc_output;
++    Monitor *monitor;
++
++    ipc_output = wl_resource_get_user_data(resource);
++    if (!ipc_output)
++        return;
++
++    monitor = ipc_output->monitor;
++    if (index >= LENGTH(layouts))
++        return;
++    if (index != monitor->lt[monitor->sellt] - layouts)
++        monitor->sellt ^= 1;
++
++    monitor->lt[monitor->sellt] = &layouts[index];
++    arrange(monitor);
++    printstatus();
++}
++
++void dwl_ipc_output_set_tag(struct wl_client *client, struct wl_resource *resource, uint32_t tagmask, uint32_t toggle_tagset) {
++    DwlIpcOutput *ipc_output;
++    Monitor *monitor;
++    unsigned int newtags = tagmask & TAGMASK;
++
++    ipc_output = wl_resource_get_user_data(resource);
++    if (!ipc_output)
++        return;
++    monitor = ipc_output->monitor;
++
++    if (!newtags)
++        return;
++    if (toggle_tagset)
++        monitor->seltags ^= 1;
++    if (newtags == monitor->tagset[monitor->seltags]) {
++        if (toggle_tagset)
++            monitor->seltags ^= 1;
++        return;
++    }
++
++    monitor->tagset[monitor->seltags] = newtags;
++    focusclient(focustop(monitor), 1);
++    arrange(monitor);
++    printstatus();
++}
++
++void dwl_ipc_output_release(struct wl_client *client, struct wl_resource *resource) {
++    wl_resource_destroy(resource);
++}
++
+ void
+ focusclient(Client *c, int lift)
+ {
+@@ -1857,6 +2059,7 @@ printstatus(void)
+ 		printf("%s tags %u %u %u %u\n", m->wlr_output->name, occ, m->tagset[m->seltags],
+ 				sel, urg);
+ 		printf("%s layout %s\n", m->wlr_output->name, m->ltsymbol);
++        dwl_ipc_output_printstatus(m);
+ 	}
+ 	fflush(stdout);
+ }
+@@ -2294,6 +2497,7 @@ setup(void)
+ 	wl_signal_add(&output_mgr->events.test, &output_mgr_test);
+ 
+ 	wlr_scene_set_presentation(scene, wlr_presentation_create(dpy, backend));
++    wl_global_create(dpy, &zdwl_ipc_manager_v1_interface, 4, NULL, dwl_ipc_manager_bind);
+ 
+ #ifdef XWAYLAND
+ 	/*
+@@ -2435,6 +2639,12 @@ toggleview(const Arg *arg)
+ 	printstatus();
+ }
+ 
++void toggle_visibility(const Arg *arg) {
++    DwlIpcOutput *ipc_output;
++    wl_list_for_each(ipc_output, &selmon->dwl_ipc_outputs, link)
++        zdwl_ipc_output_v1_send_toggle_visibility(ipc_output->resource);
++}
++
+ void
+ unlocksession(struct wl_listener *listener, void *data)
+ {
+diff --git a/protocols/dwl-ipc-unstable-v1.xml b/protocols/dwl-ipc-unstable-v1.xml
+new file mode 100644
+index 00000000..2b7c2d27
+--- /dev/null
++++ b/protocols/dwl-ipc-unstable-v1.xml
+@@ -0,0 +1,183 @@
++<?xml version="1.0" encoding="utf-8"?>
++<!--
++This is largely ripped from somebar's ipc patchset; just with some personal modifications.
++I would probably just submit raphi's patchset but I don't think that would be polite.
++-->
++<protocol name="dwl_ipc_unstable_v1">
++  <description summary="inter-proccess-communication about dwl's state">
++      This protocol allows clients to get updates from dwl and vice versa.
++
++      Warning! The protocol described in this file is experimental and
++      backward incompatible changes may be made. Backward compatible
++      changes may be added together with the corresponding interface
++      version bump.
++      Backward incompatible changes are done by bumping the version
++      number in the protocol and interface names and resetting the
++      interface version. Once the protocol is to be declared stable,
++      the 'z' prefix and the version number in the protocol and
++      interface names are removed and the interface version number is
++      reset.
++  </description>
++
++  <interface name="zdwl_ipc_manager_v1" version="4">
++    <description summary="manage dwl state">
++      This interface is exposed as a global in wl_registry.
++
++      Clients can use this interface to get a dwl_output.
++      After binding the client will revieve dwl_manager.tag and dwl_manager.layout events.
++      The dwl_manager.tag and dwl_manager.layout events expose tags and layouts to the client.
++    </description>
++
++    <request name="release" type="destructor">
++      <description summary="release dwl_manager">
++        Indicates that the client will not the dwl_manager object anymore.
++        Objects created through this instance are not affected.
++      </description>
++    </request>
++
++    <request name="get_output">
++      <description summary="get a dwl_output for a wl_output">
++        Get a dwl_output for the specified wl_output.
++      </description>
++      <arg name="id" type="new_id" interface="zdwl_ipc_output_v1"/>
++      <arg name="output" type="object" interface="wl_output"/>
++    </request>
++
++    <event name="tag">
++      <description summary="Announces a tag">
++        This event is sent after binding.
++        A roundtrip after binding guarantees the client recieved all tags.
++      </description>
++      <arg name="name" type="string"/>
++    </event>
++
++    <event name="layout">
++      <description summary="Announces a layout">
++        This event is sent after binding.
++        A roundtrip after binding guarantees the client recieved all layouts.
++      </description>
++      <arg name="name" type="string"/>
++    </event>
++  </interface>
++
++  <interface name="zdwl_ipc_output_v1" version="4">
++    <description summary="control dwl output">
++      Observe and control a dwl output.
++
++      Events are double-buffered:
++      Clients should cache events and redraw when a dwl_output.done event is sent.
++
++      Request are not double-buffered:
++      The compositor will update immediately upon request.
++    </description>
++
++    <enum name="tag_state">
++      <entry name="none" value="0" summary="no state"/>
++      <entry name="active" value="1" summary="tag is active"/>
++      <entry name="urgent" value="2" summary="tag has at least one urgent client"/>
++    </enum>
++
++    <request name="release" type="destructor">
++      <description summary="release dwl_output">
++        Indicates to that the client no longer needs this dwl_output.
++      </description>
++    </request>
++
++    <event name="toggle_visibility">
++      <description summary="Toggle client visibilty">
++        Indicates the client should hide or show themselves.
++        If the client is visible then hide, if hidden then show.
++      </description>
++    </event>
++
++    <event name="active">
++      <description summary="Update the selected output.">
++        Indicates if the output is active. Zero is invalid, nonzero is valid.
++      </description>
++      <arg name="active" type="uint"/>
++    </event>
++
++    <event name="tag">
++      <description summary="Update the state of a tag.">
++        Indicates that a tag has been updated.
++      </description>
++      <arg name="tag" type="uint" summary="Index of the tag"/>
++      <arg name="state" type="uint" enum="tag_state" summary="The state of the tag."/>
++      <arg name="clients" type="uint" summary="The number of clients in the tag."/>
++      <arg name="focused" type="uint" summary="If there is a focused client. Nonzero being valid, zero being invalid."/>
++    </event>
++
++    <event name="layout">
++      <description summary="Update the layout.">
++        Indicates a new layout is selected.
++      </description>
++      <arg name="layout" type="uint" summary="Index of the layout."/>
++    </event>
++
++    <event name="title">
++      <description summary="Update the title.">
++        Indicates the title has changed.
++      </description>
++      <arg name="title" type="string" summary="The new title name."/>
++    </event>
++
++    <event name="frame">
++      <description summary="The update sequence is done.">
++        Indicates that a sequence of status updates have finished and the client should redraw.
++      </description>
++    </event>
++
++    <request name="set_layout">
++      <description summary="Set the layout of this output"/>
++      <arg name="index" type="uint" summary="index of a layout recieved by dwl_manager.layout"/>
++    </request>
++
++    <request name="set_tags">
++      <description summary="Set the active tags of this output"/>
++      <arg name="tagmask" type="uint" summary="bitmask of the tags that should be set."/>
++      <arg name="toggle_tagset" type="uint" summary="toggle the selected tagset, zero for invalid, nonzero for valid."/>
++    </request>
++
++    <request name="set_client_tags">
++      <description summary="Set the tags of the focused client.">
++        The tags are updated as follows:
++        new_tags = (current_tags AND and_tags) XOR xor_tags
++      </description>
++      <arg name="and_tags" type="uint"/>
++      <arg name="xor_tags" type="uint"/>
++    </request>
++
++    <!-- Version 2 -->
++    <event name="appid" since="2">
++      <description summary="Update the appid.">
++        Indicates the appid has changed.
++      </description>
++      <arg name="appid" type="string" summary="The new appid."/>
++    </event>
++
++    <!-- Version 3 -->
++    <event name="layout_symbol" since="3">
++      <description summary="Update the current layout symbol">
++          Indicates the layout has changed. Since layout symbols are now dynamic.
++          As opposed to the zdwl_manager_v1.layout event, this should take precendence when displaying.
++          This also means ignoring the zdwl_output_v1.layout event.
++      </description>
++      <arg name="layout" type="string" summary="The new layout"/>
++    </event>
++
++    <!-- Version 4 -->
++    <event name="fullscreen" since="4">
++      <description summary="Update fullscreen status">
++          Indicates if the selected client on this output is fullscreen.
++      </description>
++      <arg name="is_fullscreen" type="uint" summary="If the selected client is fullscreen. Nonzero is valid, zero invalid"/>
++    </event>
++
++    <event name="floating" since="4">
++      <description summary="Update the floating status">
++          Indicates if the selected client on this output is floating.
++      </description>
++      <arg name="is_floating" type="uint" summary="If the selected client is floating. Nonzero is valid, zero invalid"/>
++    </event>
++  </interface>
++</protocol>
diff --git a/protocols/net-tapesoftware-dwl-wm-unstable-v1.xml b/protocols/net-tapesoftware-dwl-wm-unstable-v1.xml
new file mode 100644
index 0000000..4fe5b73
--- /dev/null
+++ b/protocols/net-tapesoftware-dwl-wm-unstable-v1.xml
@@ -0,0 +1,164 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="net_tapesoftware_dwl_wm_unstable_v1">
+    <copyright>
+        Copyright (c) 2021 Raphael Robatsch
+
+        Permission is hereby granted, free of charge, to any person obtaining a
+        copy of this software and associated documentation files (the
+        "Software"), to deal in the Software without restriction, including
+        without limitation the rights to use, copy, modify, merge, publish,
+        distribute, sublicense, and/or sell copies of the Software, and to
+        permit persons to whom the Software is furnished to do so, subject to
+        the following conditions:
+
+        The above copyright notice and this permission notice (including the
+        next paragraph) shall be included in all copies or substantial portions
+        of the Software.
+
+        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+        CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+        TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+    </copyright>
+
+    <interface name="znet_tapesoftware_dwl_wm_v1" version="1">
+        <description summary="control the dwl state">
+            This interface is exposed as a global in the wl_registry.
+
+            Clients can use this protocol to receive updates of the window manager
+            state (active tags, active layout, and focused window).
+            Clients can also control this state.
+
+            After binding, the client will receive the available tags and layouts
+            with the 'tag' and 'layout' events. These can be used in subsequent
+            dwl_wm_monitor_v1.set_tags/set_layout requests, and to interpret the
+            dwl_wm_monitor_v1.layout/tag events.
+        </description>
+
+        <request name="release" type="destructor">
+            <description summary="release dwl_wm">
+                This request indicates that the client will not use the dwl_wm
+                object any more. Objects that have been created through this instance
+                are not affected.
+            </description>
+        </request>
+
+        <request name="get_monitor">
+            <description summary="gets a dwl monitor from an output">
+                Gets a dwl monitor for the specified output. The window manager
+                state on the output can be controlled using the monitor.
+            </description>
+            <arg name="id" type="new_id" interface="znet_tapesoftware_dwl_wm_monitor_v1" />
+            <arg name="output" type="object" interface="wl_output" />
+        </request>
+
+        <event name="tag">
+            <description summary="announces the presence of a tag">
+                This event is sent immediately after binding.
+                A roundtrip after binding guarantees that the client has received all tags.
+            </description>
+            <arg name="name" type="string"/>
+        </event>
+
+        <event name="layout">
+            <description summary="announces the presence of a layout">
+                This event is sent immediately after binding.
+                A roundtrip after binding guarantees that the client has received all layouts.
+            </description>
+            <arg name="name" type="string"/>
+        </event>
+    </interface>
+
+    <interface name="znet_tapesoftware_dwl_wm_monitor_v1" version="1">
+        <description summary="control one monitor">
+            Observes and controls one monitor.
+
+            Events are double-buffered: Clients should cache all events and only
+            redraw themselves once the 'frame' event is sent.
+
+            Requests are not double-buffered: The compositor will update itself
+            immediately.
+        </description>
+
+        <enum name="tag_state">
+            <entry name="none" value="0" summary="no state"/>
+            <entry name="active" value="1" summary="tag is active"/>
+            <entry name="urgent" value="2" summary="tag has at least one urgent client"/>
+        </enum>
+
+        <request name="release" type="destructor">
+            <description summary="release dwl_monitor">
+                This request indicates that the client is done with this dwl_monitor.
+                All further requests are ignored.
+            </description>
+        </request>
+
+        <event name="selected">
+            <description summary="updates the selected state of the monitor">
+                If 'selected' is nonzero, this monitor is the currently selected one.
+            </description>
+            <arg name="selected" type="uint"/>
+        </event>
+
+        <event name="tag">
+            <description summary="updates the state of one tag">
+                Announces the update of a tag. num_clients and focused_client can be
+                used to draw client indicators.
+            </description>
+            <arg name="tag" type="uint" summary="index of a tag received by the dwl_wm_v1.tag event." />
+            <arg name="state" type="uint" enum="tag_state"/>
+            <arg name="num_clients" type="uint" summary="number of clients on this tag"/>
+            <arg name="focused_client" type="int" summary="out of num_clients. -1 if there is no focused client"/>
+        </event>
+
+        <event name="layout">
+            <description summary="updates the selected layout">
+                Announces the update of the selected layout.
+            </description>
+            <arg name="layout" type="uint" summary="index of a layout received by the dwl_wm_v1.layout event."/>
+        </event>
+
+        <event name="title">
+            <description summary="updates the focused client">
+                Announces the update of the selected client.
+            </description>
+            <arg name="title" type="string"/>
+        </event>
+
+        <event name="frame">
+            <description summary="end of status update sequence">
+                Sent after all other events belonging to the status update has been sent.
+                Clients should redraw themselves now.
+            </description>
+        </event>
+
+        <request name="set_tags">
+            <description summary="sets the active tags on this monitor.">
+                Changes are applied immediately.
+            </description>
+            <arg name="tagmask" type="uint" summary="bitmask of the tags that should be set."/>
+            <arg name="toggle_tagset" type="uint"/>
+        </request>
+
+        <request name="set_client_tags">
+            <description summary="updates the tags of the focused client.">
+                tags are updated as follows:
+                new_tags = (current_tags AND and_tags) XOR xor_tags
+
+                Changes are applied immediately.
+            </description>
+            <arg name="and_tags" type="uint"/>
+            <arg name="xor_tags" type="uint"/>
+        </request>
+
+        <request name="set_layout">
+            <description summary="sets the active layout on this monitor.">
+                Changes are applied immediately.
+            </description>
+            <arg name="layout" type="uint" summary="index of a layout received by the dwl_wm_v1.layout event."/>
+        </request>
+    </interface>
+</protocol>
